/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package org.openapitools.client.apis

import java.io.IOException
import okhttp3.OkHttpClient
import okhttp3.HttpUrl

import org.openapitools.client.models.MerchantsExternalOrdersOrderTokenCouponsPost200Response
import org.openapitools.client.models.MerchantsExternalOrdersOrderTokenCouponsPostRequest
import org.openapitools.client.models.MerchantsExternalOrdersOrderTokenGiftCardsPost200Response
import org.openapitools.client.models.MerchantsExternalOrdersOrderTokenGiftCardsPostRequest
import org.openapitools.client.models.MerchantsExternalOrdersOrderTokenShippingMethodsCodePatch200Response
import org.openapitools.client.models.MerchantsExternalOrdersOrderTokenShippingMethodsPost200Response
import org.openapitools.client.models.MerchantsExternalOrdersOrderTokenShippingMethodsPostRequest
import org.openapitools.client.models.MerchantsExternalOrdersOrderTokenShippingRatePost200Response
import org.openapitools.client.models.MerchantsExternalOrdersOrderTokenShippingRatePostRequest
import org.openapitools.client.models.MerchantsOrdersOrderTokenPaymentsMethodsGet200Response
import org.openapitools.client.models.MerchantsOrdersOrderTokenTransactionsVerifyPost200Response
import org.openapitools.client.models.MerchantsOrdersOrderTokenTransactionsVerifyPostRequest
import org.openapitools.client.models.MerchantsOrdersPostRequest
import org.openapitools.client.models.MerchantsTransactionsPurchasePost200Response
import org.openapitools.client.models.MerchantsTransactionsPurchasePostRequest

import com.squareup.moshi.Json

import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import org.openapitools.client.infrastructure.ApiClient
import org.openapitools.client.infrastructure.ApiResponse
import org.openapitools.client.infrastructure.ClientException
import org.openapitools.client.infrastructure.ClientError
import org.openapitools.client.infrastructure.ServerException
import org.openapitools.client.infrastructure.ServerError
import org.openapitools.client.infrastructure.MultiValueMap
import org.openapitools.client.infrastructure.PartConfig
import org.openapitools.client.infrastructure.RequestConfig
import org.openapitools.client.infrastructure.RequestMethod
import org.openapitools.client.infrastructure.ResponseType
import org.openapitools.client.infrastructure.Success
import org.openapitools.client.infrastructure.toMultiValue

class ExternalMerchantAPIApi(basePath: kotlin.String = defaultBasePath, client: OkHttpClient = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://staging-apigw.getduna.com:443")
        }
    }

    /**
     * Remove Coupon
     * Remove coupon
     * @param orderToken 
     * @param couponCode 
     * @param xApiKey  (optional)
     * @param authorization  (optional)
     * @return MerchantsExternalOrdersOrderTokenCouponsPost200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun merchantsExternalOrdersOrderTokenCouponsCouponCodeDelete(orderToken: kotlin.String, couponCode: kotlin.String, xApiKey: kotlin.String? = null, authorization: kotlin.String? = null) : MerchantsExternalOrdersOrderTokenCouponsPost200Response = withContext(Dispatchers.IO) {
        val localVarResponse = merchantsExternalOrdersOrderTokenCouponsCouponCodeDeleteWithHttpInfo(orderToken = orderToken, couponCode = couponCode, xApiKey = xApiKey, authorization = authorization)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as MerchantsExternalOrdersOrderTokenCouponsPost200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Remove Coupon
     * Remove coupon
     * @param orderToken 
     * @param couponCode 
     * @param xApiKey  (optional)
     * @param authorization  (optional)
     * @return ApiResponse<MerchantsExternalOrdersOrderTokenCouponsPost200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun merchantsExternalOrdersOrderTokenCouponsCouponCodeDeleteWithHttpInfo(orderToken: kotlin.String?, couponCode: kotlin.String?, xApiKey: kotlin.String?, authorization: kotlin.String?) : ApiResponse<MerchantsExternalOrdersOrderTokenCouponsPost200Response?> = withContext(Dispatchers.IO) {
        val localVariableConfig = merchantsExternalOrdersOrderTokenCouponsCouponCodeDeleteRequestConfig(orderToken = orderToken, couponCode = couponCode, xApiKey = xApiKey, authorization = authorization)

        return@withContext request<Unit, MerchantsExternalOrdersOrderTokenCouponsPost200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation merchantsExternalOrdersOrderTokenCouponsCouponCodeDelete
     *
     * @param orderToken 
     * @param couponCode 
     * @param xApiKey  (optional)
     * @param authorization  (optional)
     * @return RequestConfig
     */
    fun merchantsExternalOrdersOrderTokenCouponsCouponCodeDeleteRequestConfig(orderToken: kotlin.String?, couponCode: kotlin.String?, xApiKey: kotlin.String?, authorization: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        xApiKey?.apply { localVariableHeaders["X-Api-Key"] = this.toString() }
        authorization?.apply { localVariableHeaders["Authorization"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/merchants/external-orders/{order_token}/coupons/{coupon_code}".replace("{"+"order_token"+"}", encodeURIComponent(orderToken.toString())).replace("{"+"coupon_code"+"}", encodeURIComponent(couponCode.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Apply Coupon
     * Apply coupon
     * @param orderToken 
     * @param xApiKey  (optional)
     * @param authorization  (optional)
     * @param merchantsExternalOrdersOrderTokenCouponsPostRequest  (optional)
     * @return MerchantsExternalOrdersOrderTokenCouponsPost200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun merchantsExternalOrdersOrderTokenCouponsPost(orderToken: kotlin.String, xApiKey: kotlin.String? = null, authorization: kotlin.String? = null, merchantsExternalOrdersOrderTokenCouponsPostRequest: MerchantsExternalOrdersOrderTokenCouponsPostRequest? = null) : MerchantsExternalOrdersOrderTokenCouponsPost200Response = withContext(Dispatchers.IO) {
        val localVarResponse = merchantsExternalOrdersOrderTokenCouponsPostWithHttpInfo(orderToken = orderToken, xApiKey = xApiKey, authorization = authorization, merchantsExternalOrdersOrderTokenCouponsPostRequest = merchantsExternalOrdersOrderTokenCouponsPostRequest)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as MerchantsExternalOrdersOrderTokenCouponsPost200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Apply Coupon
     * Apply coupon
     * @param orderToken 
     * @param xApiKey  (optional)
     * @param authorization  (optional)
     * @param merchantsExternalOrdersOrderTokenCouponsPostRequest  (optional)
     * @return ApiResponse<MerchantsExternalOrdersOrderTokenCouponsPost200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun merchantsExternalOrdersOrderTokenCouponsPostWithHttpInfo(orderToken: kotlin.String?, xApiKey: kotlin.String?, authorization: kotlin.String?, merchantsExternalOrdersOrderTokenCouponsPostRequest: MerchantsExternalOrdersOrderTokenCouponsPostRequest?) : ApiResponse<MerchantsExternalOrdersOrderTokenCouponsPost200Response?> = withContext(Dispatchers.IO) {
        val localVariableConfig = merchantsExternalOrdersOrderTokenCouponsPostRequestConfig(orderToken = orderToken, xApiKey = xApiKey, authorization = authorization, merchantsExternalOrdersOrderTokenCouponsPostRequest = merchantsExternalOrdersOrderTokenCouponsPostRequest)

        return@withContext request<MerchantsExternalOrdersOrderTokenCouponsPostRequest, MerchantsExternalOrdersOrderTokenCouponsPost200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation merchantsExternalOrdersOrderTokenCouponsPost
     *
     * @param orderToken 
     * @param xApiKey  (optional)
     * @param authorization  (optional)
     * @param merchantsExternalOrdersOrderTokenCouponsPostRequest  (optional)
     * @return RequestConfig
     */
    fun merchantsExternalOrdersOrderTokenCouponsPostRequestConfig(orderToken: kotlin.String?, xApiKey: kotlin.String?, authorization: kotlin.String?, merchantsExternalOrdersOrderTokenCouponsPostRequest: MerchantsExternalOrdersOrderTokenCouponsPostRequest?) : RequestConfig<MerchantsExternalOrdersOrderTokenCouponsPostRequest> {
        val localVariableBody = merchantsExternalOrdersOrderTokenCouponsPostRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        xApiKey?.apply { localVariableHeaders["X-Api-Key"] = this.toString() }
        authorization?.apply { localVariableHeaders["Authorization"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/merchants/external-orders/{order_token}/coupons".replace("{"+"order_token"+"}", encodeURIComponent(orderToken.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Apply Gift Card
     * Apply Gift Card
     * @param orderToken 
     * @param xApiKey  (optional)
     * @param authorization  (optional)
     * @param merchantsExternalOrdersOrderTokenGiftCardsPostRequest  (optional)
     * @return MerchantsExternalOrdersOrderTokenGiftCardsPost200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun merchantsExternalOrdersOrderTokenGiftCardsPost(orderToken: kotlin.String, xApiKey: kotlin.String? = null, authorization: kotlin.String? = null, merchantsExternalOrdersOrderTokenGiftCardsPostRequest: MerchantsExternalOrdersOrderTokenGiftCardsPostRequest? = null) : MerchantsExternalOrdersOrderTokenGiftCardsPost200Response = withContext(Dispatchers.IO) {
        val localVarResponse = merchantsExternalOrdersOrderTokenGiftCardsPostWithHttpInfo(orderToken = orderToken, xApiKey = xApiKey, authorization = authorization, merchantsExternalOrdersOrderTokenGiftCardsPostRequest = merchantsExternalOrdersOrderTokenGiftCardsPostRequest)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as MerchantsExternalOrdersOrderTokenGiftCardsPost200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Apply Gift Card
     * Apply Gift Card
     * @param orderToken 
     * @param xApiKey  (optional)
     * @param authorization  (optional)
     * @param merchantsExternalOrdersOrderTokenGiftCardsPostRequest  (optional)
     * @return ApiResponse<MerchantsExternalOrdersOrderTokenGiftCardsPost200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun merchantsExternalOrdersOrderTokenGiftCardsPostWithHttpInfo(orderToken: kotlin.String?, xApiKey: kotlin.String?, authorization: kotlin.String?, merchantsExternalOrdersOrderTokenGiftCardsPostRequest: MerchantsExternalOrdersOrderTokenGiftCardsPostRequest?) : ApiResponse<MerchantsExternalOrdersOrderTokenGiftCardsPost200Response?> = withContext(Dispatchers.IO) {
        val localVariableConfig = merchantsExternalOrdersOrderTokenGiftCardsPostRequestConfig(orderToken = orderToken, xApiKey = xApiKey, authorization = authorization, merchantsExternalOrdersOrderTokenGiftCardsPostRequest = merchantsExternalOrdersOrderTokenGiftCardsPostRequest)

        return@withContext request<MerchantsExternalOrdersOrderTokenGiftCardsPostRequest, MerchantsExternalOrdersOrderTokenGiftCardsPost200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation merchantsExternalOrdersOrderTokenGiftCardsPost
     *
     * @param orderToken 
     * @param xApiKey  (optional)
     * @param authorization  (optional)
     * @param merchantsExternalOrdersOrderTokenGiftCardsPostRequest  (optional)
     * @return RequestConfig
     */
    fun merchantsExternalOrdersOrderTokenGiftCardsPostRequestConfig(orderToken: kotlin.String?, xApiKey: kotlin.String?, authorization: kotlin.String?, merchantsExternalOrdersOrderTokenGiftCardsPostRequest: MerchantsExternalOrdersOrderTokenGiftCardsPostRequest?) : RequestConfig<MerchantsExternalOrdersOrderTokenGiftCardsPostRequest> {
        val localVariableBody = merchantsExternalOrdersOrderTokenGiftCardsPostRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        xApiKey?.apply { localVariableHeaders["X-Api-Key"] = this.toString() }
        authorization?.apply { localVariableHeaders["Authorization"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/merchants/external-orders/{order_token}/gift-cards".replace("{"+"order_token"+"}", encodeURIComponent(orderToken.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Update the selected shipping method
     * Update the selected shipping method
     * @param orderToken 
     * @param code 
     * @param xApiKey  (optional)
     * @param authorization  (optional)
     * @return MerchantsExternalOrdersOrderTokenShippingMethodsCodePatch200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun merchantsExternalOrdersOrderTokenShippingMethodsCodePatch(orderToken: kotlin.String, code: kotlin.String, xApiKey: kotlin.String? = null, authorization: kotlin.String? = null) : MerchantsExternalOrdersOrderTokenShippingMethodsCodePatch200Response = withContext(Dispatchers.IO) {
        val localVarResponse = merchantsExternalOrdersOrderTokenShippingMethodsCodePatchWithHttpInfo(orderToken = orderToken, code = code, xApiKey = xApiKey, authorization = authorization)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as MerchantsExternalOrdersOrderTokenShippingMethodsCodePatch200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Update the selected shipping method
     * Update the selected shipping method
     * @param orderToken 
     * @param code 
     * @param xApiKey  (optional)
     * @param authorization  (optional)
     * @return ApiResponse<MerchantsExternalOrdersOrderTokenShippingMethodsCodePatch200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun merchantsExternalOrdersOrderTokenShippingMethodsCodePatchWithHttpInfo(orderToken: kotlin.String?, code: kotlin.String?, xApiKey: kotlin.String?, authorization: kotlin.String?) : ApiResponse<MerchantsExternalOrdersOrderTokenShippingMethodsCodePatch200Response?> = withContext(Dispatchers.IO) {
        val localVariableConfig = merchantsExternalOrdersOrderTokenShippingMethodsCodePatchRequestConfig(orderToken = orderToken, code = code, xApiKey = xApiKey, authorization = authorization)

        return@withContext request<Unit, MerchantsExternalOrdersOrderTokenShippingMethodsCodePatch200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation merchantsExternalOrdersOrderTokenShippingMethodsCodePatch
     *
     * @param orderToken 
     * @param code 
     * @param xApiKey  (optional)
     * @param authorization  (optional)
     * @return RequestConfig
     */
    fun merchantsExternalOrdersOrderTokenShippingMethodsCodePatchRequestConfig(orderToken: kotlin.String?, code: kotlin.String?, xApiKey: kotlin.String?, authorization: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        xApiKey?.apply { localVariableHeaders["X-Api-Key"] = this.toString() }
        authorization?.apply { localVariableHeaders["Authorization"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/merchants/external-orders/{order_token}/shipping-methods/{code}".replace("{"+"order_token"+"}", encodeURIComponent(orderToken.toString())).replace("{"+"code"+"}", encodeURIComponent(code.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Get shipping methods
     * Get shipping methods
     * @param orderToken 
     * @param xApiKey  (optional)
     * @param authorization  (optional)
     * @param merchantsExternalOrdersOrderTokenShippingMethodsPostRequest  (optional)
     * @return MerchantsExternalOrdersOrderTokenShippingMethodsPost200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun merchantsExternalOrdersOrderTokenShippingMethodsPost(orderToken: kotlin.String, xApiKey: kotlin.String? = null, authorization: kotlin.String? = null, merchantsExternalOrdersOrderTokenShippingMethodsPostRequest: MerchantsExternalOrdersOrderTokenShippingMethodsPostRequest? = null) : MerchantsExternalOrdersOrderTokenShippingMethodsPost200Response = withContext(Dispatchers.IO) {
        val localVarResponse = merchantsExternalOrdersOrderTokenShippingMethodsPostWithHttpInfo(orderToken = orderToken, xApiKey = xApiKey, authorization = authorization, merchantsExternalOrdersOrderTokenShippingMethodsPostRequest = merchantsExternalOrdersOrderTokenShippingMethodsPostRequest)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as MerchantsExternalOrdersOrderTokenShippingMethodsPost200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get shipping methods
     * Get shipping methods
     * @param orderToken 
     * @param xApiKey  (optional)
     * @param authorization  (optional)
     * @param merchantsExternalOrdersOrderTokenShippingMethodsPostRequest  (optional)
     * @return ApiResponse<MerchantsExternalOrdersOrderTokenShippingMethodsPost200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun merchantsExternalOrdersOrderTokenShippingMethodsPostWithHttpInfo(orderToken: kotlin.String?, xApiKey: kotlin.String?, authorization: kotlin.String?, merchantsExternalOrdersOrderTokenShippingMethodsPostRequest: MerchantsExternalOrdersOrderTokenShippingMethodsPostRequest?) : ApiResponse<MerchantsExternalOrdersOrderTokenShippingMethodsPost200Response?> = withContext(Dispatchers.IO) {
        val localVariableConfig = merchantsExternalOrdersOrderTokenShippingMethodsPostRequestConfig(orderToken = orderToken, xApiKey = xApiKey, authorization = authorization, merchantsExternalOrdersOrderTokenShippingMethodsPostRequest = merchantsExternalOrdersOrderTokenShippingMethodsPostRequest)

        return@withContext request<MerchantsExternalOrdersOrderTokenShippingMethodsPostRequest, MerchantsExternalOrdersOrderTokenShippingMethodsPost200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation merchantsExternalOrdersOrderTokenShippingMethodsPost
     *
     * @param orderToken 
     * @param xApiKey  (optional)
     * @param authorization  (optional)
     * @param merchantsExternalOrdersOrderTokenShippingMethodsPostRequest  (optional)
     * @return RequestConfig
     */
    fun merchantsExternalOrdersOrderTokenShippingMethodsPostRequestConfig(orderToken: kotlin.String?, xApiKey: kotlin.String?, authorization: kotlin.String?, merchantsExternalOrdersOrderTokenShippingMethodsPostRequest: MerchantsExternalOrdersOrderTokenShippingMethodsPostRequest?) : RequestConfig<MerchantsExternalOrdersOrderTokenShippingMethodsPostRequest> {
        val localVariableBody = merchantsExternalOrdersOrderTokenShippingMethodsPostRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        xApiKey?.apply { localVariableHeaders["X-Api-Key"] = this.toString() }
        authorization?.apply { localVariableHeaders["Authorization"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/merchants/external-orders/{order_token}/shipping-methods".replace("{"+"order_token"+"}", encodeURIComponent(orderToken.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Shipping Rate
     * Get shipping rate
     * @param orderToken 
     * @param xApiKey  (optional)
     * @param authorization  (optional)
     * @param lat  (optional)
     * @param lon  (optional)
     * @param city  (optional)
     * @param countryIso  (optional)
     * @param merchantsExternalOrdersOrderTokenShippingRatePostRequest  (optional)
     * @return MerchantsExternalOrdersOrderTokenShippingRatePost200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun merchantsExternalOrdersOrderTokenShippingRatePost(orderToken: kotlin.String, xApiKey: kotlin.String? = null, authorization: kotlin.String? = null, lat: kotlin.String? = null, lon: kotlin.String? = null, city: kotlin.String? = null, countryIso: kotlin.String? = null, merchantsExternalOrdersOrderTokenShippingRatePostRequest: MerchantsExternalOrdersOrderTokenShippingRatePostRequest? = null) : MerchantsExternalOrdersOrderTokenShippingRatePost200Response = withContext(Dispatchers.IO) {
        val localVarResponse = merchantsExternalOrdersOrderTokenShippingRatePostWithHttpInfo(orderToken = orderToken, xApiKey = xApiKey, authorization = authorization, lat = lat, lon = lon, city = city, countryIso = countryIso, merchantsExternalOrdersOrderTokenShippingRatePostRequest = merchantsExternalOrdersOrderTokenShippingRatePostRequest)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as MerchantsExternalOrdersOrderTokenShippingRatePost200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Shipping Rate
     * Get shipping rate
     * @param orderToken 
     * @param xApiKey  (optional)
     * @param authorization  (optional)
     * @param lat  (optional)
     * @param lon  (optional)
     * @param city  (optional)
     * @param countryIso  (optional)
     * @param merchantsExternalOrdersOrderTokenShippingRatePostRequest  (optional)
     * @return ApiResponse<MerchantsExternalOrdersOrderTokenShippingRatePost200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun merchantsExternalOrdersOrderTokenShippingRatePostWithHttpInfo(orderToken: kotlin.String?, xApiKey: kotlin.String?, authorization: kotlin.String?, lat: kotlin.String?, lon: kotlin.String?, city: kotlin.String?, countryIso: kotlin.String?, merchantsExternalOrdersOrderTokenShippingRatePostRequest: MerchantsExternalOrdersOrderTokenShippingRatePostRequest?) : ApiResponse<MerchantsExternalOrdersOrderTokenShippingRatePost200Response?> = withContext(Dispatchers.IO) {
        val localVariableConfig = merchantsExternalOrdersOrderTokenShippingRatePostRequestConfig(orderToken = orderToken, xApiKey = xApiKey, authorization = authorization, lat = lat, lon = lon, city = city, countryIso = countryIso, merchantsExternalOrdersOrderTokenShippingRatePostRequest = merchantsExternalOrdersOrderTokenShippingRatePostRequest)

        return@withContext request<MerchantsExternalOrdersOrderTokenShippingRatePostRequest, MerchantsExternalOrdersOrderTokenShippingRatePost200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation merchantsExternalOrdersOrderTokenShippingRatePost
     *
     * @param orderToken 
     * @param xApiKey  (optional)
     * @param authorization  (optional)
     * @param lat  (optional)
     * @param lon  (optional)
     * @param city  (optional)
     * @param countryIso  (optional)
     * @param merchantsExternalOrdersOrderTokenShippingRatePostRequest  (optional)
     * @return RequestConfig
     */
    fun merchantsExternalOrdersOrderTokenShippingRatePostRequestConfig(orderToken: kotlin.String?, xApiKey: kotlin.String?, authorization: kotlin.String?, lat: kotlin.String?, lon: kotlin.String?, city: kotlin.String?, countryIso: kotlin.String?, merchantsExternalOrdersOrderTokenShippingRatePostRequest: MerchantsExternalOrdersOrderTokenShippingRatePostRequest?) : RequestConfig<MerchantsExternalOrdersOrderTokenShippingRatePostRequest> {
        val localVariableBody = merchantsExternalOrdersOrderTokenShippingRatePostRequest
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (lat != null) {
                    put("lat", listOf(lat.toString()))
                }
                if (lon != null) {
                    put("lon", listOf(lon.toString()))
                }
                if (city != null) {
                    put("city", listOf(city.toString()))
                }
                if (countryIso != null) {
                    put("country_iso", listOf(countryIso.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        xApiKey?.apply { localVariableHeaders["X-Api-Key"] = this.toString() }
        authorization?.apply { localVariableHeaders["Authorization"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/merchants/external-orders/{order_token}/shipping-rate".replace("{"+"order_token"+"}", encodeURIComponent(orderToken.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Get order
     * Get order by token
     * @param orderToken 
     * @param xApiKey  (optional)
     * @return MerchantsExternalOrdersOrderTokenCouponsPost200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun merchantsOrdersOrderTokenGet(orderToken: kotlin.String, xApiKey: kotlin.String? = null) : MerchantsExternalOrdersOrderTokenCouponsPost200Response = withContext(Dispatchers.IO) {
        val localVarResponse = merchantsOrdersOrderTokenGetWithHttpInfo(orderToken = orderToken, xApiKey = xApiKey)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as MerchantsExternalOrdersOrderTokenCouponsPost200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get order
     * Get order by token
     * @param orderToken 
     * @param xApiKey  (optional)
     * @return ApiResponse<MerchantsExternalOrdersOrderTokenCouponsPost200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun merchantsOrdersOrderTokenGetWithHttpInfo(orderToken: kotlin.String?, xApiKey: kotlin.String?) : ApiResponse<MerchantsExternalOrdersOrderTokenCouponsPost200Response?> = withContext(Dispatchers.IO) {
        val localVariableConfig = merchantsOrdersOrderTokenGetRequestConfig(orderToken = orderToken, xApiKey = xApiKey)

        return@withContext request<Unit, MerchantsExternalOrdersOrderTokenCouponsPost200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation merchantsOrdersOrderTokenGet
     *
     * @param orderToken 
     * @param xApiKey  (optional)
     * @return RequestConfig
     */
    fun merchantsOrdersOrderTokenGetRequestConfig(orderToken: kotlin.String?, xApiKey: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        xApiKey?.apply { localVariableHeaders["X-Api-Key"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/merchants/orders/{order_token}".replace("{"+"order_token"+"}", encodeURIComponent(orderToken.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Payment Methods
     * Get payment methods
     * @param orderToken 
     * @param authorization  (optional)
     * @param xApiKey  (optional)
     * @param xStoreCode  (optional)
     * @return MerchantsOrdersOrderTokenPaymentsMethodsGet200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun merchantsOrdersOrderTokenPaymentsMethodsGet(orderToken: kotlin.String, authorization: kotlin.String? = null, xApiKey: kotlin.String? = null, xStoreCode: kotlin.String? = null) : MerchantsOrdersOrderTokenPaymentsMethodsGet200Response = withContext(Dispatchers.IO) {
        val localVarResponse = merchantsOrdersOrderTokenPaymentsMethodsGetWithHttpInfo(orderToken = orderToken, authorization = authorization, xApiKey = xApiKey, xStoreCode = xStoreCode)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as MerchantsOrdersOrderTokenPaymentsMethodsGet200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Payment Methods
     * Get payment methods
     * @param orderToken 
     * @param authorization  (optional)
     * @param xApiKey  (optional)
     * @param xStoreCode  (optional)
     * @return ApiResponse<MerchantsOrdersOrderTokenPaymentsMethodsGet200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun merchantsOrdersOrderTokenPaymentsMethodsGetWithHttpInfo(orderToken: kotlin.String?, authorization: kotlin.String?, xApiKey: kotlin.String?, xStoreCode: kotlin.String?) : ApiResponse<MerchantsOrdersOrderTokenPaymentsMethodsGet200Response?> = withContext(Dispatchers.IO) {
        val localVariableConfig = merchantsOrdersOrderTokenPaymentsMethodsGetRequestConfig(orderToken = orderToken, authorization = authorization, xApiKey = xApiKey, xStoreCode = xStoreCode)

        return@withContext request<Unit, MerchantsOrdersOrderTokenPaymentsMethodsGet200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation merchantsOrdersOrderTokenPaymentsMethodsGet
     *
     * @param orderToken 
     * @param authorization  (optional)
     * @param xApiKey  (optional)
     * @param xStoreCode  (optional)
     * @return RequestConfig
     */
    fun merchantsOrdersOrderTokenPaymentsMethodsGetRequestConfig(orderToken: kotlin.String?, authorization: kotlin.String?, xApiKey: kotlin.String?, xStoreCode: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        authorization?.apply { localVariableHeaders["Authorization"] = this.toString() }
        xApiKey?.apply { localVariableHeaders["X-Api-Key"] = this.toString() }
        xStoreCode?.apply { localVariableHeaders["X-Store-Code"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/merchants/orders/{order_token}/payments-methods".replace("{"+"order_token"+"}", encodeURIComponent(orderToken.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Verify OTP Dinners
     * Verify OTP Dinners
     * @param orderToken 
     * @param authorization  (optional)
     * @param xApiKey  (optional)
     * @param xMerchantID  (optional)
     * @param xStoreCode  (optional)
     * @param merchantsOrdersOrderTokenTransactionsVerifyPostRequest  (optional)
     * @return MerchantsOrdersOrderTokenTransactionsVerifyPost200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun merchantsOrdersOrderTokenTransactionsVerifyPost(orderToken: kotlin.String, authorization: kotlin.String? = null, xApiKey: kotlin.String? = null, xMerchantID: kotlin.String? = null, xStoreCode: kotlin.String? = null, merchantsOrdersOrderTokenTransactionsVerifyPostRequest: MerchantsOrdersOrderTokenTransactionsVerifyPostRequest? = null) : MerchantsOrdersOrderTokenTransactionsVerifyPost200Response = withContext(Dispatchers.IO) {
        val localVarResponse = merchantsOrdersOrderTokenTransactionsVerifyPostWithHttpInfo(orderToken = orderToken, authorization = authorization, xApiKey = xApiKey, xMerchantID = xMerchantID, xStoreCode = xStoreCode, merchantsOrdersOrderTokenTransactionsVerifyPostRequest = merchantsOrdersOrderTokenTransactionsVerifyPostRequest)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as MerchantsOrdersOrderTokenTransactionsVerifyPost200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Verify OTP Dinners
     * Verify OTP Dinners
     * @param orderToken 
     * @param authorization  (optional)
     * @param xApiKey  (optional)
     * @param xMerchantID  (optional)
     * @param xStoreCode  (optional)
     * @param merchantsOrdersOrderTokenTransactionsVerifyPostRequest  (optional)
     * @return ApiResponse<MerchantsOrdersOrderTokenTransactionsVerifyPost200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun merchantsOrdersOrderTokenTransactionsVerifyPostWithHttpInfo(orderToken: kotlin.String?, authorization: kotlin.String?, xApiKey: kotlin.String?, xMerchantID: kotlin.String?, xStoreCode: kotlin.String?, merchantsOrdersOrderTokenTransactionsVerifyPostRequest: MerchantsOrdersOrderTokenTransactionsVerifyPostRequest?) : ApiResponse<MerchantsOrdersOrderTokenTransactionsVerifyPost200Response?> = withContext(Dispatchers.IO) {
        val localVariableConfig = merchantsOrdersOrderTokenTransactionsVerifyPostRequestConfig(orderToken = orderToken, authorization = authorization, xApiKey = xApiKey, xMerchantID = xMerchantID, xStoreCode = xStoreCode, merchantsOrdersOrderTokenTransactionsVerifyPostRequest = merchantsOrdersOrderTokenTransactionsVerifyPostRequest)

        return@withContext request<MerchantsOrdersOrderTokenTransactionsVerifyPostRequest, MerchantsOrdersOrderTokenTransactionsVerifyPost200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation merchantsOrdersOrderTokenTransactionsVerifyPost
     *
     * @param orderToken 
     * @param authorization  (optional)
     * @param xApiKey  (optional)
     * @param xMerchantID  (optional)
     * @param xStoreCode  (optional)
     * @param merchantsOrdersOrderTokenTransactionsVerifyPostRequest  (optional)
     * @return RequestConfig
     */
    fun merchantsOrdersOrderTokenTransactionsVerifyPostRequestConfig(orderToken: kotlin.String?, authorization: kotlin.String?, xApiKey: kotlin.String?, xMerchantID: kotlin.String?, xStoreCode: kotlin.String?, merchantsOrdersOrderTokenTransactionsVerifyPostRequest: MerchantsOrdersOrderTokenTransactionsVerifyPostRequest?) : RequestConfig<MerchantsOrdersOrderTokenTransactionsVerifyPostRequest> {
        val localVariableBody = merchantsOrdersOrderTokenTransactionsVerifyPostRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        authorization?.apply { localVariableHeaders["Authorization"] = this.toString() }
        xApiKey?.apply { localVariableHeaders["X-Api-Key"] = this.toString() }
        xMerchantID?.apply { localVariableHeaders["X-Merchant-ID"] = this.toString() }
        xStoreCode?.apply { localVariableHeaders["X-Store-Code"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/merchants/orders/{order_token}/transactions/verify".replace("{"+"order_token"+"}", encodeURIComponent(orderToken.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Create Order
     * Create order
     * @param xApiKey  (optional)
     * @param merchantsOrdersPostRequest  (optional)
     * @return MerchantsExternalOrdersOrderTokenCouponsPost200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun merchantsOrdersPost(xApiKey: kotlin.String? = null, merchantsOrdersPostRequest: MerchantsOrdersPostRequest? = null) : MerchantsExternalOrdersOrderTokenCouponsPost200Response = withContext(Dispatchers.IO) {
        val localVarResponse = merchantsOrdersPostWithHttpInfo(xApiKey = xApiKey, merchantsOrdersPostRequest = merchantsOrdersPostRequest)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as MerchantsExternalOrdersOrderTokenCouponsPost200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Create Order
     * Create order
     * @param xApiKey  (optional)
     * @param merchantsOrdersPostRequest  (optional)
     * @return ApiResponse<MerchantsExternalOrdersOrderTokenCouponsPost200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun merchantsOrdersPostWithHttpInfo(xApiKey: kotlin.String?, merchantsOrdersPostRequest: MerchantsOrdersPostRequest?) : ApiResponse<MerchantsExternalOrdersOrderTokenCouponsPost200Response?> = withContext(Dispatchers.IO) {
        val localVariableConfig = merchantsOrdersPostRequestConfig(xApiKey = xApiKey, merchantsOrdersPostRequest = merchantsOrdersPostRequest)

        return@withContext request<MerchantsOrdersPostRequest, MerchantsExternalOrdersOrderTokenCouponsPost200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation merchantsOrdersPost
     *
     * @param xApiKey  (optional)
     * @param merchantsOrdersPostRequest  (optional)
     * @return RequestConfig
     */
    fun merchantsOrdersPostRequestConfig(xApiKey: kotlin.String?, merchantsOrdersPostRequest: MerchantsOrdersPostRequest?) : RequestConfig<MerchantsOrdersPostRequest> {
        val localVariableBody = merchantsOrdersPostRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        xApiKey?.apply { localVariableHeaders["X-Api-Key"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/merchants/orders",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Purchase
     * Purchase
     * @param authorization  (optional)
     * @param xApiKey  (optional)
     * @param xMerchantID  (optional)
     * @param xStoreCode  (optional)
     * @param xDeviceId  (optional)
     * @param xSessionId  (optional)
     * @param userAgent  (optional)
     * @param merchantsTransactionsPurchasePostRequest  (optional)
     * @return MerchantsTransactionsPurchasePost200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun merchantsTransactionsPurchasePost(authorization: kotlin.String? = null, xApiKey: kotlin.String? = null, xMerchantID: kotlin.String? = null, xStoreCode: kotlin.String? = null, xDeviceId: kotlin.String? = null, xSessionId: kotlin.String? = null, userAgent: kotlin.String? = null, merchantsTransactionsPurchasePostRequest: MerchantsTransactionsPurchasePostRequest? = null) : MerchantsTransactionsPurchasePost200Response = withContext(Dispatchers.IO) {
        val localVarResponse = merchantsTransactionsPurchasePostWithHttpInfo(authorization = authorization, xApiKey = xApiKey, xMerchantID = xMerchantID, xStoreCode = xStoreCode, xDeviceId = xDeviceId, xSessionId = xSessionId, userAgent = userAgent, merchantsTransactionsPurchasePostRequest = merchantsTransactionsPurchasePostRequest)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as MerchantsTransactionsPurchasePost200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Purchase
     * Purchase
     * @param authorization  (optional)
     * @param xApiKey  (optional)
     * @param xMerchantID  (optional)
     * @param xStoreCode  (optional)
     * @param xDeviceId  (optional)
     * @param xSessionId  (optional)
     * @param userAgent  (optional)
     * @param merchantsTransactionsPurchasePostRequest  (optional)
     * @return ApiResponse<MerchantsTransactionsPurchasePost200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun merchantsTransactionsPurchasePostWithHttpInfo(authorization: kotlin.String?, xApiKey: kotlin.String?, xMerchantID: kotlin.String?, xStoreCode: kotlin.String?, xDeviceId: kotlin.String?, xSessionId: kotlin.String?, userAgent: kotlin.String?, merchantsTransactionsPurchasePostRequest: MerchantsTransactionsPurchasePostRequest?) : ApiResponse<MerchantsTransactionsPurchasePost200Response?> = withContext(Dispatchers.IO) {
        val localVariableConfig = merchantsTransactionsPurchasePostRequestConfig(authorization = authorization, xApiKey = xApiKey, xMerchantID = xMerchantID, xStoreCode = xStoreCode, xDeviceId = xDeviceId, xSessionId = xSessionId, userAgent = userAgent, merchantsTransactionsPurchasePostRequest = merchantsTransactionsPurchasePostRequest)

        return@withContext request<MerchantsTransactionsPurchasePostRequest, MerchantsTransactionsPurchasePost200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation merchantsTransactionsPurchasePost
     *
     * @param authorization  (optional)
     * @param xApiKey  (optional)
     * @param xMerchantID  (optional)
     * @param xStoreCode  (optional)
     * @param xDeviceId  (optional)
     * @param xSessionId  (optional)
     * @param userAgent  (optional)
     * @param merchantsTransactionsPurchasePostRequest  (optional)
     * @return RequestConfig
     */
    fun merchantsTransactionsPurchasePostRequestConfig(authorization: kotlin.String?, xApiKey: kotlin.String?, xMerchantID: kotlin.String?, xStoreCode: kotlin.String?, xDeviceId: kotlin.String?, xSessionId: kotlin.String?, userAgent: kotlin.String?, merchantsTransactionsPurchasePostRequest: MerchantsTransactionsPurchasePostRequest?) : RequestConfig<MerchantsTransactionsPurchasePostRequest> {
        val localVariableBody = merchantsTransactionsPurchasePostRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        authorization?.apply { localVariableHeaders["Authorization"] = this.toString() }
        xApiKey?.apply { localVariableHeaders["X-Api-Key"] = this.toString() }
        xMerchantID?.apply { localVariableHeaders["X-Merchant-ID"] = this.toString() }
        xStoreCode?.apply { localVariableHeaders["X-Store-Code"] = this.toString() }
        xDeviceId?.apply { localVariableHeaders["X-Device-Id"] = this.toString() }
        xSessionId?.apply { localVariableHeaders["X-Session-Id"] = this.toString() }
        userAgent?.apply { localVariableHeaders["User-Agent"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/merchants/transactions/purchase",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
