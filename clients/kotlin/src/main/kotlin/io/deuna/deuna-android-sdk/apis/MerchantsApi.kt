/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package io.deuna.deuna-android-sdk.apis

import java.io.IOException
import okhttp3.OkHttpClient
import okhttp3.HttpUrl

import io.deuna.deuna-android-sdk.models.CreateMerchant200Response
import io.deuna.deuna-android-sdk.models.CreateMerchant400Response
import io.deuna.deuna-android-sdk.models.CreateMerchantRequest
import io.deuna.deuna-android-sdk.models.CreateMerchantStore200Response
import io.deuna.deuna-android-sdk.models.CreateMerchantStoreRequest
import io.deuna.deuna-android-sdk.models.CreatePublicKey201Response
import io.deuna.deuna-android-sdk.models.GetAllMerchants200Response
import io.deuna.deuna-android-sdk.models.GetMerchant200Response
import io.deuna.deuna-android-sdk.models.GetMerchantStores200Response
import io.deuna.deuna-android-sdk.models.IdentityToken200Response
import io.deuna.deuna-android-sdk.models.Login200Response
import io.deuna.deuna-android-sdk.models.LoginRequest
import io.deuna.deuna-android-sdk.models.Me200Response
import io.deuna.deuna-android-sdk.models.RegisterMerchantToken200Response
import io.deuna.deuna-android-sdk.models.RegisterMerchantUsers200Response
import io.deuna.deuna-android-sdk.models.RegisterMerchantUsers400Response
import io.deuna.deuna-android-sdk.models.RegisterMerchantUsers500Response
import io.deuna.deuna-android-sdk.models.RegisterMerchantUsersRequest
import io.deuna.deuna-android-sdk.models.UpdateMerchantRequest

import com.squareup.moshi.Json

import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import io.deuna.deuna-android-sdk.infrastructure.ApiClient
import io.deuna.deuna-android-sdk.infrastructure.ApiResponse
import io.deuna.deuna-android-sdk.infrastructure.ClientException
import io.deuna.deuna-android-sdk.infrastructure.ClientError
import io.deuna.deuna-android-sdk.infrastructure.ServerException
import io.deuna.deuna-android-sdk.infrastructure.ServerError
import io.deuna.deuna-android-sdk.infrastructure.MultiValueMap
import io.deuna.deuna-android-sdk.infrastructure.PartConfig
import io.deuna.deuna-android-sdk.infrastructure.RequestConfig
import io.deuna.deuna-android-sdk.infrastructure.RequestMethod
import io.deuna.deuna-android-sdk.infrastructure.ResponseType
import io.deuna.deuna-android-sdk.infrastructure.Success
import io.deuna.deuna-android-sdk.infrastructure.toMultiValue

class MerchantsApi(basePath: kotlin.String = defaultBasePath, client: OkHttpClient = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://staging-apigw.getduna.com:443")
        }
    }

    /**
     * Create merchant
     * Create merchant
     * @param xApiKey  (optional)
     * @param createMerchantRequest  (optional)
     * @return CreateMerchant200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun createMerchant(xApiKey: kotlin.String? = null, createMerchantRequest: CreateMerchantRequest? = null) : CreateMerchant200Response = withContext(Dispatchers.IO) {
        val localVarResponse = createMerchantWithHttpInfo(xApiKey = xApiKey, createMerchantRequest = createMerchantRequest)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CreateMerchant200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Create merchant
     * Create merchant
     * @param xApiKey  (optional)
     * @param createMerchantRequest  (optional)
     * @return ApiResponse<CreateMerchant200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun createMerchantWithHttpInfo(xApiKey: kotlin.String?, createMerchantRequest: CreateMerchantRequest?) : ApiResponse<CreateMerchant200Response?> = withContext(Dispatchers.IO) {
        val localVariableConfig = createMerchantRequestConfig(xApiKey = xApiKey, createMerchantRequest = createMerchantRequest)

        return@withContext request<CreateMerchantRequest, CreateMerchant200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation createMerchant
     *
     * @param xApiKey  (optional)
     * @param createMerchantRequest  (optional)
     * @return RequestConfig
     */
    fun createMerchantRequestConfig(xApiKey: kotlin.String?, createMerchantRequest: CreateMerchantRequest?) : RequestConfig<CreateMerchantRequest> {
        val localVariableBody = createMerchantRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        xApiKey?.apply { localVariableHeaders["X-Api-Key"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/merchants",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Create Merchant Store
     * Create Merchant Store
     * @param merchantId 
     * @param authorization  (optional)
     * @param xApiKey  (optional)
     * @param createMerchantStoreRequest  (optional)
     * @return CreateMerchantStore200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun createMerchantStore(merchantId: kotlin.String, authorization: kotlin.String? = null, xApiKey: kotlin.String? = null, createMerchantStoreRequest: CreateMerchantStoreRequest? = null) : CreateMerchantStore200Response = withContext(Dispatchers.IO) {
        val localVarResponse = createMerchantStoreWithHttpInfo(merchantId = merchantId, authorization = authorization, xApiKey = xApiKey, createMerchantStoreRequest = createMerchantStoreRequest)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CreateMerchantStore200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Create Merchant Store
     * Create Merchant Store
     * @param merchantId 
     * @param authorization  (optional)
     * @param xApiKey  (optional)
     * @param createMerchantStoreRequest  (optional)
     * @return ApiResponse<CreateMerchantStore200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun createMerchantStoreWithHttpInfo(merchantId: kotlin.String?, authorization: kotlin.String?, xApiKey: kotlin.String?, createMerchantStoreRequest: CreateMerchantStoreRequest?) : ApiResponse<CreateMerchantStore200Response?> = withContext(Dispatchers.IO) {
        val localVariableConfig = createMerchantStoreRequestConfig(merchantId = merchantId, authorization = authorization, xApiKey = xApiKey, createMerchantStoreRequest = createMerchantStoreRequest)

        return@withContext request<CreateMerchantStoreRequest, CreateMerchantStore200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation createMerchantStore
     *
     * @param merchantId 
     * @param authorization  (optional)
     * @param xApiKey  (optional)
     * @param createMerchantStoreRequest  (optional)
     * @return RequestConfig
     */
    fun createMerchantStoreRequestConfig(merchantId: kotlin.String?, authorization: kotlin.String?, xApiKey: kotlin.String?, createMerchantStoreRequest: CreateMerchantStoreRequest?) : RequestConfig<CreateMerchantStoreRequest> {
        val localVariableBody = createMerchantStoreRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        authorization?.apply { localVariableHeaders["Authorization"] = this.toString() }
        xApiKey?.apply { localVariableHeaders["X-Api-Key"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/merchants/{merchant_id}/stores".replace("{"+"merchant_id"+"}", encodeURIComponent(merchantId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Create Public Key
     * Create Public Key
     * @param merchantId 
     * @param xApiKey  (optional)
     * @return CreatePublicKey201Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun createPublicKey(merchantId: kotlin.String, xApiKey: kotlin.String? = null) : CreatePublicKey201Response = withContext(Dispatchers.IO) {
        val localVarResponse = createPublicKeyWithHttpInfo(merchantId = merchantId, xApiKey = xApiKey)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CreatePublicKey201Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Create Public Key
     * Create Public Key
     * @param merchantId 
     * @param xApiKey  (optional)
     * @return ApiResponse<CreatePublicKey201Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun createPublicKeyWithHttpInfo(merchantId: kotlin.String?, xApiKey: kotlin.String?) : ApiResponse<CreatePublicKey201Response?> = withContext(Dispatchers.IO) {
        val localVariableConfig = createPublicKeyRequestConfig(merchantId = merchantId, xApiKey = xApiKey)

        return@withContext request<Unit, CreatePublicKey201Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation createPublicKey
     *
     * @param merchantId 
     * @param xApiKey  (optional)
     * @return RequestConfig
     */
    fun createPublicKeyRequestConfig(merchantId: kotlin.String?, xApiKey: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        xApiKey?.apply { localVariableHeaders["X-Api-Key"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/merchants/{merchant_id}/public-keys".replace("{"+"merchant_id"+"}", encodeURIComponent(merchantId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Get All Merchants
     * Get All Merchants
     * @param authorization  (optional)
     * @return GetAllMerchants200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun getAllMerchants(authorization: kotlin.String? = null) : GetAllMerchants200Response = withContext(Dispatchers.IO) {
        val localVarResponse = getAllMerchantsWithHttpInfo(authorization = authorization)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetAllMerchants200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get All Merchants
     * Get All Merchants
     * @param authorization  (optional)
     * @return ApiResponse<GetAllMerchants200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun getAllMerchantsWithHttpInfo(authorization: kotlin.String?) : ApiResponse<GetAllMerchants200Response?> = withContext(Dispatchers.IO) {
        val localVariableConfig = getAllMerchantsRequestConfig(authorization = authorization)

        return@withContext request<Unit, GetAllMerchants200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getAllMerchants
     *
     * @param authorization  (optional)
     * @return RequestConfig
     */
    fun getAllMerchantsRequestConfig(authorization: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        authorization?.apply { localVariableHeaders["Authorization"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/merchants-all",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Get merchant
     * Get merchant
     * @param merchantId 
     * @param xApiKey  (optional)
     * @return GetMerchant200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun getMerchant(merchantId: kotlin.String, xApiKey: kotlin.String? = null) : GetMerchant200Response = withContext(Dispatchers.IO) {
        val localVarResponse = getMerchantWithHttpInfo(merchantId = merchantId, xApiKey = xApiKey)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetMerchant200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get merchant
     * Get merchant
     * @param merchantId 
     * @param xApiKey  (optional)
     * @return ApiResponse<GetMerchant200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun getMerchantWithHttpInfo(merchantId: kotlin.String?, xApiKey: kotlin.String?) : ApiResponse<GetMerchant200Response?> = withContext(Dispatchers.IO) {
        val localVariableConfig = getMerchantRequestConfig(merchantId = merchantId, xApiKey = xApiKey)

        return@withContext request<Unit, GetMerchant200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getMerchant
     *
     * @param merchantId 
     * @param xApiKey  (optional)
     * @return RequestConfig
     */
    fun getMerchantRequestConfig(merchantId: kotlin.String?, xApiKey: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        xApiKey?.apply { localVariableHeaders["X-Api-Key"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/merchants/{merchant_id}".replace("{"+"merchant_id"+"}", encodeURIComponent(merchantId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Get Merchant Stores
     * Get Merchant Store
     * @param merchantId 
     * @param authorization  (optional)
     * @param xApiKey  (optional)
     * @return GetMerchantStores200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun getMerchantStores(merchantId: kotlin.String, authorization: kotlin.String? = null, xApiKey: kotlin.String? = null) : GetMerchantStores200Response = withContext(Dispatchers.IO) {
        val localVarResponse = getMerchantStoresWithHttpInfo(merchantId = merchantId, authorization = authorization, xApiKey = xApiKey)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetMerchantStores200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get Merchant Stores
     * Get Merchant Store
     * @param merchantId 
     * @param authorization  (optional)
     * @param xApiKey  (optional)
     * @return ApiResponse<GetMerchantStores200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun getMerchantStoresWithHttpInfo(merchantId: kotlin.String?, authorization: kotlin.String?, xApiKey: kotlin.String?) : ApiResponse<GetMerchantStores200Response?> = withContext(Dispatchers.IO) {
        val localVariableConfig = getMerchantStoresRequestConfig(merchantId = merchantId, authorization = authorization, xApiKey = xApiKey)

        return@withContext request<Unit, GetMerchantStores200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getMerchantStores
     *
     * @param merchantId 
     * @param authorization  (optional)
     * @param xApiKey  (optional)
     * @return RequestConfig
     */
    fun getMerchantStoresRequestConfig(merchantId: kotlin.String?, authorization: kotlin.String?, xApiKey: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        authorization?.apply { localVariableHeaders["Authorization"] = this.toString() }
        xApiKey?.apply { localVariableHeaders["X-Api-Key"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/merchants/{merchant_id}/stores".replace("{"+"merchant_id"+"}", encodeURIComponent(merchantId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Identity Token
     * Identity Token
     * @param authorization  (optional)
     * @return IdentityToken200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun identityToken(authorization: kotlin.String? = null) : IdentityToken200Response = withContext(Dispatchers.IO) {
        val localVarResponse = identityTokenWithHttpInfo(authorization = authorization)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as IdentityToken200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Identity Token
     * Identity Token
     * @param authorization  (optional)
     * @return ApiResponse<IdentityToken200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun identityTokenWithHttpInfo(authorization: kotlin.String?) : ApiResponse<IdentityToken200Response?> = withContext(Dispatchers.IO) {
        val localVariableConfig = identityTokenRequestConfig(authorization = authorization)

        return@withContext request<Unit, IdentityToken200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation identityToken
     *
     * @param authorization  (optional)
     * @return RequestConfig
     */
    fun identityTokenRequestConfig(authorization: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        authorization?.apply { localVariableHeaders["Authorization"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/merchants/identity-token",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Login
     * Make a Merchant Login
     * @param xApiKey  (optional)
     * @param loginRequest  (optional)
     * @return Login200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun login(xApiKey: kotlin.String? = null, loginRequest: LoginRequest? = null) : Login200Response = withContext(Dispatchers.IO) {
        val localVarResponse = loginWithHttpInfo(xApiKey = xApiKey, loginRequest = loginRequest)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Login200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Login
     * Make a Merchant Login
     * @param xApiKey  (optional)
     * @param loginRequest  (optional)
     * @return ApiResponse<Login200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun loginWithHttpInfo(xApiKey: kotlin.String?, loginRequest: LoginRequest?) : ApiResponse<Login200Response?> = withContext(Dispatchers.IO) {
        val localVariableConfig = loginRequestConfig(xApiKey = xApiKey, loginRequest = loginRequest)

        return@withContext request<LoginRequest, Login200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation login
     *
     * @param xApiKey  (optional)
     * @param loginRequest  (optional)
     * @return RequestConfig
     */
    fun loginRequestConfig(xApiKey: kotlin.String?, loginRequest: LoginRequest?) : RequestConfig<LoginRequest> {
        val localVariableBody = loginRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        xApiKey?.apply { localVariableHeaders["X-Api-Key"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/merchants/login",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Get Information
     * Getting Merchant Information
     * @param authorization  (optional)
     * @return Me200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun me(authorization: kotlin.String? = null) : Me200Response = withContext(Dispatchers.IO) {
        val localVarResponse = meWithHttpInfo(authorization = authorization)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Me200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get Information
     * Getting Merchant Information
     * @param authorization  (optional)
     * @return ApiResponse<Me200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun meWithHttpInfo(authorization: kotlin.String?) : ApiResponse<Me200Response?> = withContext(Dispatchers.IO) {
        val localVariableConfig = meRequestConfig(authorization = authorization)

        return@withContext request<Unit, Me200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation me
     *
     * @param authorization  (optional)
     * @return RequestConfig
     */
    fun meRequestConfig(authorization: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        authorization?.apply { localVariableHeaders["Authorization"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/merchants-tokens/me",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Register Merchant Token
     * Register Merchant Token
     * @param merchantId 
     * @param authorization  (optional)
     * @return RegisterMerchantToken200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun registerMerchantToken(merchantId: kotlin.String, authorization: kotlin.String? = null) : RegisterMerchantToken200Response = withContext(Dispatchers.IO) {
        val localVarResponse = registerMerchantTokenWithHttpInfo(merchantId = merchantId, authorization = authorization)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RegisterMerchantToken200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Register Merchant Token
     * Register Merchant Token
     * @param merchantId 
     * @param authorization  (optional)
     * @return ApiResponse<RegisterMerchantToken200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun registerMerchantTokenWithHttpInfo(merchantId: kotlin.String?, authorization: kotlin.String?) : ApiResponse<RegisterMerchantToken200Response?> = withContext(Dispatchers.IO) {
        val localVariableConfig = registerMerchantTokenRequestConfig(merchantId = merchantId, authorization = authorization)

        return@withContext request<Unit, RegisterMerchantToken200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation registerMerchantToken
     *
     * @param merchantId 
     * @param authorization  (optional)
     * @return RequestConfig
     */
    fun registerMerchantTokenRequestConfig(merchantId: kotlin.String?, authorization: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        authorization?.apply { localVariableHeaders["Authorization"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/merchants/{merchant_id}/tokens".replace("{"+"merchant_id"+"}", encodeURIComponent(merchantId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Register Merchant User
     * Register Merchant User
     * @param xApiKey  (optional)
     * @param registerMerchantUsersRequest  (optional)
     * @return RegisterMerchantUsers200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun registerMerchantUser(xApiKey: kotlin.String? = null, registerMerchantUsersRequest: RegisterMerchantUsersRequest? = null) : RegisterMerchantUsers200Response = withContext(Dispatchers.IO) {
        val localVarResponse = registerMerchantUserWithHttpInfo(xApiKey = xApiKey, registerMerchantUsersRequest = registerMerchantUsersRequest)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RegisterMerchantUsers200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Register Merchant User
     * Register Merchant User
     * @param xApiKey  (optional)
     * @param registerMerchantUsersRequest  (optional)
     * @return ApiResponse<RegisterMerchantUsers200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun registerMerchantUserWithHttpInfo(xApiKey: kotlin.String?, registerMerchantUsersRequest: RegisterMerchantUsersRequest?) : ApiResponse<RegisterMerchantUsers200Response?> = withContext(Dispatchers.IO) {
        val localVariableConfig = registerMerchantUserRequestConfig(xApiKey = xApiKey, registerMerchantUsersRequest = registerMerchantUsersRequest)

        return@withContext request<RegisterMerchantUsersRequest, RegisterMerchantUsers200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation registerMerchantUser
     *
     * @param xApiKey  (optional)
     * @param registerMerchantUsersRequest  (optional)
     * @return RequestConfig
     */
    fun registerMerchantUserRequestConfig(xApiKey: kotlin.String?, registerMerchantUsersRequest: RegisterMerchantUsersRequest?) : RequestConfig<RegisterMerchantUsersRequest> {
        val localVariableBody = registerMerchantUsersRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        xApiKey?.apply { localVariableHeaders["X-Api-Key"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/merchants/users",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Register Merchant User
     * Register Merchant User
     * @param authorization  (optional)
     * @param registerMerchantUsersRequest  (optional)
     * @return RegisterMerchantUsers200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun registerMerchantUsers(authorization: kotlin.String? = null, registerMerchantUsersRequest: RegisterMerchantUsersRequest? = null) : RegisterMerchantUsers200Response = withContext(Dispatchers.IO) {
        val localVarResponse = registerMerchantUsersWithHttpInfo(authorization = authorization, registerMerchantUsersRequest = registerMerchantUsersRequest)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RegisterMerchantUsers200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Register Merchant User
     * Register Merchant User
     * @param authorization  (optional)
     * @param registerMerchantUsersRequest  (optional)
     * @return ApiResponse<RegisterMerchantUsers200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun registerMerchantUsersWithHttpInfo(authorization: kotlin.String?, registerMerchantUsersRequest: RegisterMerchantUsersRequest?) : ApiResponse<RegisterMerchantUsers200Response?> = withContext(Dispatchers.IO) {
        val localVariableConfig = registerMerchantUsersRequestConfig(authorization = authorization, registerMerchantUsersRequest = registerMerchantUsersRequest)

        return@withContext request<RegisterMerchantUsersRequest, RegisterMerchantUsers200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation registerMerchantUsers
     *
     * @param authorization  (optional)
     * @param registerMerchantUsersRequest  (optional)
     * @return RequestConfig
     */
    fun registerMerchantUsersRequestConfig(authorization: kotlin.String?, registerMerchantUsersRequest: RegisterMerchantUsersRequest?) : RequestConfig<RegisterMerchantUsersRequest> {
        val localVariableBody = registerMerchantUsersRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        authorization?.apply { localVariableHeaders["Authorization"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/merchant-users",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Update merchant
     * Update merchant
     * @param merchantId 
     * @param xApiKey  (optional)
     * @param updateMerchantRequest  (optional)
     * @return GetMerchant200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun updateMerchant(merchantId: kotlin.String, xApiKey: kotlin.String? = null, updateMerchantRequest: UpdateMerchantRequest? = null) : GetMerchant200Response = withContext(Dispatchers.IO) {
        val localVarResponse = updateMerchantWithHttpInfo(merchantId = merchantId, xApiKey = xApiKey, updateMerchantRequest = updateMerchantRequest)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetMerchant200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Update merchant
     * Update merchant
     * @param merchantId 
     * @param xApiKey  (optional)
     * @param updateMerchantRequest  (optional)
     * @return ApiResponse<GetMerchant200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun updateMerchantWithHttpInfo(merchantId: kotlin.String?, xApiKey: kotlin.String?, updateMerchantRequest: UpdateMerchantRequest?) : ApiResponse<GetMerchant200Response?> = withContext(Dispatchers.IO) {
        val localVariableConfig = updateMerchantRequestConfig(merchantId = merchantId, xApiKey = xApiKey, updateMerchantRequest = updateMerchantRequest)

        return@withContext request<UpdateMerchantRequest, GetMerchant200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation updateMerchant
     *
     * @param merchantId 
     * @param xApiKey  (optional)
     * @param updateMerchantRequest  (optional)
     * @return RequestConfig
     */
    fun updateMerchantRequestConfig(merchantId: kotlin.String?, xApiKey: kotlin.String?, updateMerchantRequest: UpdateMerchantRequest?) : RequestConfig<UpdateMerchantRequest> {
        val localVariableBody = updateMerchantRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        xApiKey?.apply { localVariableHeaders["X-Api-Key"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/merchants/{merchant_id}".replace("{"+"merchant_id"+"}", encodeURIComponent(merchantId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
