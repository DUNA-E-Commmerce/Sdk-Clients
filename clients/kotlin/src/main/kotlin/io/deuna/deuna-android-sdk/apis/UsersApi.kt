/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package io.deuna.deuna-android-sdk.apis

import java.io.IOException
import okhttp3.OkHttpClient
import okhttp3.HttpUrl

import io.deuna.deuna-android-sdk.models.CreateAddress200Response
import io.deuna.deuna-android-sdk.models.CreateAddressRequest
import io.deuna.deuna-android-sdk.models.ExternalAuthorize200Response
import io.deuna.deuna-android-sdk.models.ExternalAuthorizeRefresh200Response
import io.deuna.deuna-android-sdk.models.GetMerchantsPaymentsMethods401Response
import io.deuna.deuna-android-sdk.models.GetUserAddresses200Response
import io.deuna.deuna-android-sdk.models.GetUserAddresses403Response
import io.deuna.deuna-android-sdk.models.GetUserAddresses501Response
import io.deuna.deuna-android-sdk.models.GetUserCardById200Response
import io.deuna.deuna-android-sdk.models.GetUserCards200Response
import io.deuna.deuna-android-sdk.models.GetUserCards401Response
import io.deuna.deuna-android-sdk.models.GetUserInformation200Response
import io.deuna.deuna-android-sdk.models.LoginWithOtp200Response
import io.deuna.deuna-android-sdk.models.LoginWithOtp403Response
import io.deuna.deuna-android-sdk.models.LoginWithOtpRequest
import io.deuna.deuna-android-sdk.models.OrderToken401Response
import io.deuna.deuna-android-sdk.models.PostUsersUserIdCards422Response
import io.deuna.deuna-android-sdk.models.RegisterMerchantUsers500Response
import io.deuna.deuna-android-sdk.models.RegisterUser200Response
import io.deuna.deuna-android-sdk.models.RegisterUserRequest
import io.deuna.deuna-android-sdk.models.RequestOtp500Response
import io.deuna.deuna-android-sdk.models.RequestOtpRequest
import io.deuna.deuna-android-sdk.models.UsersLoginDeviceFingerprintPost200Response
import io.deuna.deuna-android-sdk.models.UsersRegister201Response
import io.deuna.deuna-android-sdk.models.UsersRegister409Response
import io.deuna.deuna-android-sdk.models.UsersRegisterRequest

import com.squareup.moshi.Json

import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import io.deuna.deuna-android-sdk.infrastructure.ApiClient
import io.deuna.deuna-android-sdk.infrastructure.ApiResponse
import io.deuna.deuna-android-sdk.infrastructure.ClientException
import io.deuna.deuna-android-sdk.infrastructure.ClientError
import io.deuna.deuna-android-sdk.infrastructure.ServerException
import io.deuna.deuna-android-sdk.infrastructure.ServerError
import io.deuna.deuna-android-sdk.infrastructure.MultiValueMap
import io.deuna.deuna-android-sdk.infrastructure.PartConfig
import io.deuna.deuna-android-sdk.infrastructure.RequestConfig
import io.deuna.deuna-android-sdk.infrastructure.RequestMethod
import io.deuna.deuna-android-sdk.infrastructure.ResponseType
import io.deuna.deuna-android-sdk.infrastructure.Success
import io.deuna.deuna-android-sdk.infrastructure.toMultiValue

class UsersApi(basePath: kotlin.String = defaultBasePath, client: OkHttpClient = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://staging-apigw.getduna.com:443")
        }
    }

    /**
     * Crear nueva dirección para el usuario
     * Permite crear una dirección para el usuario
     * @param userId 
     * @param xApiKey  (optional)
     * @param createAddressRequest  (optional)
     * @return CreateAddress200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun createAddress(userId: kotlin.String, xApiKey: kotlin.String? = null, createAddressRequest: CreateAddressRequest? = null) : CreateAddress200Response = withContext(Dispatchers.IO) {
        val localVarResponse = createAddressWithHttpInfo(userId = userId, xApiKey = xApiKey, createAddressRequest = createAddressRequest)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CreateAddress200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Crear nueva dirección para el usuario
     * Permite crear una dirección para el usuario
     * @param userId 
     * @param xApiKey  (optional)
     * @param createAddressRequest  (optional)
     * @return ApiResponse<CreateAddress200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun createAddressWithHttpInfo(userId: kotlin.String?, xApiKey: kotlin.String?, createAddressRequest: CreateAddressRequest?) : ApiResponse<CreateAddress200Response?> = withContext(Dispatchers.IO) {
        val localVariableConfig = createAddressRequestConfig(userId = userId, xApiKey = xApiKey, createAddressRequest = createAddressRequest)

        return@withContext request<CreateAddressRequest, CreateAddress200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation createAddress
     *
     * @param userId 
     * @param xApiKey  (optional)
     * @param createAddressRequest  (optional)
     * @return RequestConfig
     */
    fun createAddressRequestConfig(userId: kotlin.String?, xApiKey: kotlin.String?, createAddressRequest: CreateAddressRequest?) : RequestConfig<CreateAddressRequest> {
        val localVariableBody = createAddressRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        xApiKey?.apply { localVariableHeaders["X-Api-Key"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/users/{user_id}/addresses".replace("{"+"user_id"+"}", encodeURIComponent(userId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Remove card by identifier
     * Remove card by identifier
     * @param userId 
     * @param cardId 
     * @param xApiKey  (optional)
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun deleteUserCardById(userId: kotlin.String, cardId: kotlin.String, xApiKey: kotlin.String? = null) : Unit = withContext(Dispatchers.IO) {
        val localVarResponse = deleteUserCardByIdWithHttpInfo(userId = userId, cardId = cardId, xApiKey = xApiKey)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Remove card by identifier
     * Remove card by identifier
     * @param userId 
     * @param cardId 
     * @param xApiKey  (optional)
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun deleteUserCardByIdWithHttpInfo(userId: kotlin.String?, cardId: kotlin.String?, xApiKey: kotlin.String?) : ApiResponse<Unit?> = withContext(Dispatchers.IO) {
        val localVariableConfig = deleteUserCardByIdRequestConfig(userId = userId, cardId = cardId, xApiKey = xApiKey)

        return@withContext request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation deleteUserCardById
     *
     * @param userId 
     * @param cardId 
     * @param xApiKey  (optional)
     * @return RequestConfig
     */
    fun deleteUserCardByIdRequestConfig(userId: kotlin.String?, cardId: kotlin.String?, xApiKey: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        xApiKey?.apply { localVariableHeaders["X-Api-Key"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/users/{user_id}/cards/{card_id}".replace("{"+"user_id"+"}", encodeURIComponent(userId.toString())).replace("{"+"card_id"+"}", encodeURIComponent(cardId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Eliminar dirección
     * Permite eliminar una dirección del usuario dado su identificador 
     * @param userId 
     * @param addressId 
     * @param authorization  (optional)
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun deleteUsersAddress(userId: kotlin.String, addressId: kotlin.String, authorization: kotlin.String? = null) : Unit = withContext(Dispatchers.IO) {
        val localVarResponse = deleteUsersAddressWithHttpInfo(userId = userId, addressId = addressId, authorization = authorization)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Eliminar dirección
     * Permite eliminar una dirección del usuario dado su identificador 
     * @param userId 
     * @param addressId 
     * @param authorization  (optional)
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun deleteUsersAddressWithHttpInfo(userId: kotlin.String?, addressId: kotlin.String?, authorization: kotlin.String?) : ApiResponse<Unit?> = withContext(Dispatchers.IO) {
        val localVariableConfig = deleteUsersAddressRequestConfig(userId = userId, addressId = addressId, authorization = authorization)

        return@withContext request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation deleteUsersAddress
     *
     * @param userId 
     * @param addressId 
     * @param authorization  (optional)
     * @return RequestConfig
     */
    fun deleteUsersAddressRequestConfig(userId: kotlin.String?, addressId: kotlin.String?, authorization: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        authorization?.apply { localVariableHeaders["Authorization"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/users/{user_id}/addresses/{address_id}".replace("{"+"user_id"+"}", encodeURIComponent(userId.toString())).replace("{"+"address_id"+"}", encodeURIComponent(addressId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Eliminar Usuario
     * Permite eliminar un usuario de la red DEUNA.
     * @param userId 
     * @param xApiKey  (optional)
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun deleteUsersUserId(userId: kotlin.String, xApiKey: kotlin.String? = null) : Unit = withContext(Dispatchers.IO) {
        val localVarResponse = deleteUsersUserIdWithHttpInfo(userId = userId, xApiKey = xApiKey)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Eliminar Usuario
     * Permite eliminar un usuario de la red DEUNA.
     * @param userId 
     * @param xApiKey  (optional)
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun deleteUsersUserIdWithHttpInfo(userId: kotlin.String?, xApiKey: kotlin.String?) : ApiResponse<Unit?> = withContext(Dispatchers.IO) {
        val localVariableConfig = deleteUsersUserIdRequestConfig(userId = userId, xApiKey = xApiKey)

        return@withContext request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation deleteUsersUserId
     *
     * @param userId 
     * @param xApiKey  (optional)
     * @return RequestConfig
     */
    fun deleteUsersUserIdRequestConfig(userId: kotlin.String?, xApiKey: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        xApiKey?.apply { localVariableHeaders["X-Api-Key"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/users/{user_id}".replace("{"+"user_id"+"}", encodeURIComponent(userId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Edit User
     * Editing User
     * @param userId 
     * @param registerUserRequest Ejemplo de requestBody
     * @param xApiKey  (optional)
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun editUser(userId: kotlin.String, registerUserRequest: RegisterUserRequest, xApiKey: kotlin.String? = null) : Unit = withContext(Dispatchers.IO) {
        val localVarResponse = editUserWithHttpInfo(userId = userId, registerUserRequest = registerUserRequest, xApiKey = xApiKey)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Edit User
     * Editing User
     * @param userId 
     * @param registerUserRequest Ejemplo de requestBody
     * @param xApiKey  (optional)
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun editUserWithHttpInfo(userId: kotlin.String?, registerUserRequest: RegisterUserRequest?, xApiKey: kotlin.String?) : ApiResponse<Unit?> = withContext(Dispatchers.IO) {
        val localVariableConfig = editUserRequestConfig(userId = userId, registerUserRequest = registerUserRequest, xApiKey = xApiKey)

        return@withContext request<RegisterUserRequest, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation editUser
     *
     * @param userId 
     * @param registerUserRequest Ejemplo de requestBody
     * @param xApiKey  (optional)
     * @return RequestConfig
     */
    fun editUserRequestConfig(userId: kotlin.String?, registerUserRequest: RegisterUserRequest?, xApiKey: kotlin.String?) : RequestConfig<RegisterUserRequest> {
        val localVariableBody = registerUserRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        xApiKey?.apply { localVariableHeaders["X-Api-Key"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/users/{user_id}".replace("{"+"user_id"+"}", encodeURIComponent(userId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Iniciar sesión - autorización externa
     * Entregar de forma segura un token autorizado por DEUNA ONE y el cliente.
     * @param xApiKey  (optional)
     * @param authorization  (optional)
     * @return ExternalAuthorize200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun externalAuthorize(xApiKey: kotlin.String? = null, authorization: kotlin.String? = null) : ExternalAuthorize200Response = withContext(Dispatchers.IO) {
        val localVarResponse = externalAuthorizeWithHttpInfo(xApiKey = xApiKey, authorization = authorization)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ExternalAuthorize200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Iniciar sesión - autorización externa
     * Entregar de forma segura un token autorizado por DEUNA ONE y el cliente.
     * @param xApiKey  (optional)
     * @param authorization  (optional)
     * @return ApiResponse<ExternalAuthorize200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun externalAuthorizeWithHttpInfo(xApiKey: kotlin.String?, authorization: kotlin.String?) : ApiResponse<ExternalAuthorize200Response?> = withContext(Dispatchers.IO) {
        val localVariableConfig = externalAuthorizeRequestConfig(xApiKey = xApiKey, authorization = authorization)

        return@withContext request<Unit, ExternalAuthorize200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation externalAuthorize
     *
     * @param xApiKey  (optional)
     * @param authorization  (optional)
     * @return RequestConfig
     */
    fun externalAuthorizeRequestConfig(xApiKey: kotlin.String?, authorization: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        xApiKey?.apply { localVariableHeaders["X-Api-Key"] = this.toString() }
        authorization?.apply { localVariableHeaders["Authorization"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/users/external-authorize",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Actualizar token
     * Obtener un nuevo token de forma segura a partir de un refresh_token autorizado por DEUNA ONE y el cliente.
     * @param xApiKey  (optional)
     * @param authorization  (optional)
     * @return ExternalAuthorizeRefresh200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun externalAuthorizeRefresh(xApiKey: kotlin.String? = null, authorization: kotlin.String? = null) : ExternalAuthorizeRefresh200Response = withContext(Dispatchers.IO) {
        val localVarResponse = externalAuthorizeRefreshWithHttpInfo(xApiKey = xApiKey, authorization = authorization)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ExternalAuthorizeRefresh200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Actualizar token
     * Obtener un nuevo token de forma segura a partir de un refresh_token autorizado por DEUNA ONE y el cliente.
     * @param xApiKey  (optional)
     * @param authorization  (optional)
     * @return ApiResponse<ExternalAuthorizeRefresh200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun externalAuthorizeRefreshWithHttpInfo(xApiKey: kotlin.String?, authorization: kotlin.String?) : ApiResponse<ExternalAuthorizeRefresh200Response?> = withContext(Dispatchers.IO) {
        val localVariableConfig = externalAuthorizeRefreshRequestConfig(xApiKey = xApiKey, authorization = authorization)

        return@withContext request<Unit, ExternalAuthorizeRefresh200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation externalAuthorizeRefresh
     *
     * @param xApiKey  (optional)
     * @param authorization  (optional)
     * @return RequestConfig
     */
    fun externalAuthorizeRefreshRequestConfig(xApiKey: kotlin.String?, authorization: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        xApiKey?.apply { localVariableHeaders["X-Api-Key"] = this.toString() }
        authorization?.apply { localVariableHeaders["Authorization"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/users/authorize",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Obtener todas direcciones del usuario
     * 
     * @param userId 
     * @param authorization  (optional)
     * @return GetUserAddresses200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun getUserAddresses(userId: kotlin.String, authorization: kotlin.String? = null) : GetUserAddresses200Response = withContext(Dispatchers.IO) {
        val localVarResponse = getUserAddressesWithHttpInfo(userId = userId, authorization = authorization)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetUserAddresses200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Obtener todas direcciones del usuario
     * 
     * @param userId 
     * @param authorization  (optional)
     * @return ApiResponse<GetUserAddresses200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun getUserAddressesWithHttpInfo(userId: kotlin.String?, authorization: kotlin.String?) : ApiResponse<GetUserAddresses200Response?> = withContext(Dispatchers.IO) {
        val localVariableConfig = getUserAddressesRequestConfig(userId = userId, authorization = authorization)

        return@withContext request<Unit, GetUserAddresses200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getUserAddresses
     *
     * @param userId 
     * @param authorization  (optional)
     * @return RequestConfig
     */
    fun getUserAddressesRequestConfig(userId: kotlin.String?, authorization: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        authorization?.apply { localVariableHeaders["Authorization"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/users/{user_id}/addresses".replace("{"+"user_id"+"}", encodeURIComponent(userId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Obtain a card by its identifier.
     * Obtain a card by its identifier.
     * @param userId 
     * @param cardId 
     * @param xApiKey  (optional)
     * @return GetUserCardById200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun getUserCardById(userId: kotlin.String, cardId: kotlin.String, xApiKey: kotlin.String? = null) : GetUserCardById200Response = withContext(Dispatchers.IO) {
        val localVarResponse = getUserCardByIdWithHttpInfo(userId = userId, cardId = cardId, xApiKey = xApiKey)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetUserCardById200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Obtain a card by its identifier.
     * Obtain a card by its identifier.
     * @param userId 
     * @param cardId 
     * @param xApiKey  (optional)
     * @return ApiResponse<GetUserCardById200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun getUserCardByIdWithHttpInfo(userId: kotlin.String?, cardId: kotlin.String?, xApiKey: kotlin.String?) : ApiResponse<GetUserCardById200Response?> = withContext(Dispatchers.IO) {
        val localVariableConfig = getUserCardByIdRequestConfig(userId = userId, cardId = cardId, xApiKey = xApiKey)

        return@withContext request<Unit, GetUserCardById200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getUserCardById
     *
     * @param userId 
     * @param cardId 
     * @param xApiKey  (optional)
     * @return RequestConfig
     */
    fun getUserCardByIdRequestConfig(userId: kotlin.String?, cardId: kotlin.String?, xApiKey: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        xApiKey?.apply { localVariableHeaders["X-Api-Key"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/users/{user_id}/cards/{card_id}".replace("{"+"user_id"+"}", encodeURIComponent(userId.toString())).replace("{"+"card_id"+"}", encodeURIComponent(cardId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Get all user cards
     * Get all user cards
     * @param userId 
     * @param xApiKey  (optional)
     * @return GetUserCards200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun getUserCards(userId: kotlin.String, xApiKey: kotlin.String? = null) : GetUserCards200Response = withContext(Dispatchers.IO) {
        val localVarResponse = getUserCardsWithHttpInfo(userId = userId, xApiKey = xApiKey)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetUserCards200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get all user cards
     * Get all user cards
     * @param userId 
     * @param xApiKey  (optional)
     * @return ApiResponse<GetUserCards200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun getUserCardsWithHttpInfo(userId: kotlin.String?, xApiKey: kotlin.String?) : ApiResponse<GetUserCards200Response?> = withContext(Dispatchers.IO) {
        val localVariableConfig = getUserCardsRequestConfig(userId = userId, xApiKey = xApiKey)

        return@withContext request<Unit, GetUserCards200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getUserCards
     *
     * @param userId 
     * @param xApiKey  (optional)
     * @return RequestConfig
     */
    fun getUserCardsRequestConfig(userId: kotlin.String?, xApiKey: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        xApiKey?.apply { localVariableHeaders["X-Api-Key"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/users/{user_id}/cards".replace("{"+"user_id"+"}", encodeURIComponent(userId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Get User Information
     * Get User Information
     * @param xApiKey  (optional)
     * @param authorization  (optional)
     * @return GetUserInformation200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun getUserInformation(xApiKey: kotlin.String? = null, authorization: kotlin.String? = null) : GetUserInformation200Response = withContext(Dispatchers.IO) {
        val localVarResponse = getUserInformationWithHttpInfo(xApiKey = xApiKey, authorization = authorization)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetUserInformation200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get User Information
     * Get User Information
     * @param xApiKey  (optional)
     * @param authorization  (optional)
     * @return ApiResponse<GetUserInformation200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun getUserInformationWithHttpInfo(xApiKey: kotlin.String?, authorization: kotlin.String?) : ApiResponse<GetUserInformation200Response?> = withContext(Dispatchers.IO) {
        val localVariableConfig = getUserInformationRequestConfig(xApiKey = xApiKey, authorization = authorization)

        return@withContext request<Unit, GetUserInformation200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getUserInformation
     *
     * @param xApiKey  (optional)
     * @param authorization  (optional)
     * @return RequestConfig
     */
    fun getUserInformationRequestConfig(xApiKey: kotlin.String?, authorization: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        xApiKey?.apply { localVariableHeaders["X-Api-Key"] = this.toString() }
        authorization?.apply { localVariableHeaders["Authorization"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/users/me",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Login con OTP
     * Permite iniciar sesión con el código OTP enviado al correo o al teléfono del usuario. **Esto se debe especificar en el query param.** 
     * @param loginWithOtpRequest  (optional)
     * @return LoginWithOtp200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun loginWithOtp(loginWithOtpRequest: LoginWithOtpRequest? = null) : LoginWithOtp200Response = withContext(Dispatchers.IO) {
        val localVarResponse = loginWithOtpWithHttpInfo(loginWithOtpRequest = loginWithOtpRequest)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as LoginWithOtp200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Login con OTP
     * Permite iniciar sesión con el código OTP enviado al correo o al teléfono del usuario. **Esto se debe especificar en el query param.** 
     * @param loginWithOtpRequest  (optional)
     * @return ApiResponse<LoginWithOtp200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun loginWithOtpWithHttpInfo(loginWithOtpRequest: LoginWithOtpRequest?) : ApiResponse<LoginWithOtp200Response?> = withContext(Dispatchers.IO) {
        val localVariableConfig = loginWithOtpRequestConfig(loginWithOtpRequest = loginWithOtpRequest)

        return@withContext request<LoginWithOtpRequest, LoginWithOtp200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation loginWithOtp
     *
     * @param loginWithOtpRequest  (optional)
     * @return RequestConfig
     */
    fun loginWithOtpRequestConfig(loginWithOtpRequest: LoginWithOtpRequest?) : RequestConfig<LoginWithOtpRequest> {
        val localVariableBody = loginWithOtpRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/users/login",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * Actualizar dirección
     * Permite actualizar los datos de una dirección mediante el id del mismo
     * @param userId 
     * @param addressId 
     * @param authorization  (optional)
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun patchUserAddress(userId: kotlin.String, addressId: kotlin.String, authorization: kotlin.String? = null) : Unit = withContext(Dispatchers.IO) {
        val localVarResponse = patchUserAddressWithHttpInfo(userId = userId, addressId = addressId, authorization = authorization)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Actualizar dirección
     * Permite actualizar los datos de una dirección mediante el id del mismo
     * @param userId 
     * @param addressId 
     * @param authorization  (optional)
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun patchUserAddressWithHttpInfo(userId: kotlin.String?, addressId: kotlin.String?, authorization: kotlin.String?) : ApiResponse<Unit?> = withContext(Dispatchers.IO) {
        val localVariableConfig = patchUserAddressRequestConfig(userId = userId, addressId = addressId, authorization = authorization)

        return@withContext request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation patchUserAddress
     *
     * @param userId 
     * @param addressId 
     * @param authorization  (optional)
     * @return RequestConfig
     */
    fun patchUserAddressRequestConfig(userId: kotlin.String?, addressId: kotlin.String?, authorization: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        authorization?.apply { localVariableHeaders["Authorization"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/users/{user_id}/addresses/{address_id}".replace("{"+"user_id"+"}", encodeURIComponent(userId.toString())).replace("{"+"address_id"+"}", encodeURIComponent(addressId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Register User
     * Allow register user
     * @param registerUserRequest Ejemplo de requestBody
     * @param xApiKey  (optional)
     * @return RegisterUser200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun registerUser(registerUserRequest: RegisterUserRequest, xApiKey: kotlin.String? = null) : RegisterUser200Response = withContext(Dispatchers.IO) {
        val localVarResponse = registerUserWithHttpInfo(registerUserRequest = registerUserRequest, xApiKey = xApiKey)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RegisterUser200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Register User
     * Allow register user
     * @param registerUserRequest Ejemplo de requestBody
     * @param xApiKey  (optional)
     * @return ApiResponse<RegisterUser200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun registerUserWithHttpInfo(registerUserRequest: RegisterUserRequest?, xApiKey: kotlin.String?) : ApiResponse<RegisterUser200Response?> = withContext(Dispatchers.IO) {
        val localVariableConfig = registerUserRequestConfig(registerUserRequest = registerUserRequest, xApiKey = xApiKey)

        return@withContext request<RegisterUserRequest, RegisterUser200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation registerUser
     *
     * @param registerUserRequest Ejemplo de requestBody
     * @param xApiKey  (optional)
     * @return RequestConfig
     */
    fun registerUserRequestConfig(registerUserRequest: RegisterUserRequest?, xApiKey: kotlin.String?) : RequestConfig<RegisterUserRequest> {
        val localVariableBody = registerUserRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        xApiKey?.apply { localVariableHeaders["X-Api-Key"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/users/signup",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Enviar código OTP
     * Enviar el OTP (One time password) al correo o teléfono del usuario. **Esto se debe especificar en el query param.**
     * @param requestOtpRequest  (optional)
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun requestOtp(requestOtpRequest: RequestOtpRequest? = null) : Unit = withContext(Dispatchers.IO) {
        val localVarResponse = requestOtpWithHttpInfo(requestOtpRequest = requestOtpRequest)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Enviar código OTP
     * Enviar el OTP (One time password) al correo o teléfono del usuario. **Esto se debe especificar en el query param.**
     * @param requestOtpRequest  (optional)
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun requestOtpWithHttpInfo(requestOtpRequest: RequestOtpRequest?) : ApiResponse<Unit?> = withContext(Dispatchers.IO) {
        val localVariableConfig = requestOtpRequestConfig(requestOtpRequest = requestOtpRequest)

        return@withContext request<RequestOtpRequest, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation requestOtp
     *
     * @param requestOtpRequest  (optional)
     * @return RequestConfig
     */
    fun requestOtpRequestConfig(requestOtpRequest: RequestOtpRequest?) : RequestConfig<RequestOtpRequest> {
        val localVariableBody = requestOtpRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/users/request-code",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * Users Exists
     * Get if user exists
     * @param xApiKey  (optional)
     * @param email  (optional)
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun userExists(xApiKey: kotlin.String? = null, email: kotlin.String? = null) : Unit = withContext(Dispatchers.IO) {
        val localVarResponse = userExistsWithHttpInfo(xApiKey = xApiKey, email = email)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Users Exists
     * Get if user exists
     * @param xApiKey  (optional)
     * @param email  (optional)
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun userExistsWithHttpInfo(xApiKey: kotlin.String?, email: kotlin.String?) : ApiResponse<Unit?> = withContext(Dispatchers.IO) {
        val localVariableConfig = userExistsRequestConfig(xApiKey = xApiKey, email = email)

        return@withContext request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation userExists
     *
     * @param xApiKey  (optional)
     * @param email  (optional)
     * @return RequestConfig
     */
    fun userExistsRequestConfig(xApiKey: kotlin.String?, email: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (email != null) {
                    put("email", listOf(email.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        xApiKey?.apply { localVariableHeaders["X-Api-Key"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/users",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Login User
     * Login User
     * @param xApiKey  (optional)
     * @param authorization  (optional)
     * @return UsersLoginDeviceFingerprintPost200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun usersLoginDeviceFingerprintPost(xApiKey: kotlin.String? = null, authorization: kotlin.String? = null) : UsersLoginDeviceFingerprintPost200Response = withContext(Dispatchers.IO) {
        val localVarResponse = usersLoginDeviceFingerprintPostWithHttpInfo(xApiKey = xApiKey, authorization = authorization)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as UsersLoginDeviceFingerprintPost200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Login User
     * Login User
     * @param xApiKey  (optional)
     * @param authorization  (optional)
     * @return ApiResponse<UsersLoginDeviceFingerprintPost200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun usersLoginDeviceFingerprintPostWithHttpInfo(xApiKey: kotlin.String?, authorization: kotlin.String?) : ApiResponse<UsersLoginDeviceFingerprintPost200Response?> = withContext(Dispatchers.IO) {
        val localVariableConfig = usersLoginDeviceFingerprintPostRequestConfig(xApiKey = xApiKey, authorization = authorization)

        return@withContext request<Unit, UsersLoginDeviceFingerprintPost200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation usersLoginDeviceFingerprintPost
     *
     * @param xApiKey  (optional)
     * @param authorization  (optional)
     * @return RequestConfig
     */
    fun usersLoginDeviceFingerprintPostRequestConfig(xApiKey: kotlin.String?, authorization: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        xApiKey?.apply { localVariableHeaders["X-Api-Key"] = this.toString() }
        authorization?.apply { localVariableHeaders["Authorization"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/users/login/device-fingerprint",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Registro de usuario
     * Registrar un usuario de tu comercio, este usuario una vez registrado pertenecera a la Red DEUNA
     * @param xApiKey  (optional)
     * @param authorization  (optional)
     * @param usersRegisterRequest  (optional)
     * @return UsersRegister201Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun usersRegister(xApiKey: kotlin.String? = null, authorization: kotlin.String? = null, usersRegisterRequest: UsersRegisterRequest? = null) : UsersRegister201Response = withContext(Dispatchers.IO) {
        val localVarResponse = usersRegisterWithHttpInfo(xApiKey = xApiKey, authorization = authorization, usersRegisterRequest = usersRegisterRequest)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as UsersRegister201Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Registro de usuario
     * Registrar un usuario de tu comercio, este usuario una vez registrado pertenecera a la Red DEUNA
     * @param xApiKey  (optional)
     * @param authorization  (optional)
     * @param usersRegisterRequest  (optional)
     * @return ApiResponse<UsersRegister201Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun usersRegisterWithHttpInfo(xApiKey: kotlin.String?, authorization: kotlin.String?, usersRegisterRequest: UsersRegisterRequest?) : ApiResponse<UsersRegister201Response?> = withContext(Dispatchers.IO) {
        val localVariableConfig = usersRegisterRequestConfig(xApiKey = xApiKey, authorization = authorization, usersRegisterRequest = usersRegisterRequest)

        return@withContext request<UsersRegisterRequest, UsersRegister201Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation usersRegister
     *
     * @param xApiKey  (optional)
     * @param authorization  (optional)
     * @param usersRegisterRequest  (optional)
     * @return RequestConfig
     */
    fun usersRegisterRequestConfig(xApiKey: kotlin.String?, authorization: kotlin.String?, usersRegisterRequest: UsersRegisterRequest?) : RequestConfig<UsersRegisterRequest> {
        val localVariableBody = usersRegisterRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        xApiKey?.apply { localVariableHeaders["X-Api-Key"] = this.toString() }
        authorization?.apply { localVariableHeaders["Authorization"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/users/register",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
