/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package io.deuna.deuna-android-sdk.apis

import java.io.IOException
import okhttp3.OkHttpClient
import okhttp3.HttpUrl

import io.deuna.deuna-android-sdk.models.CancelOrderRequest
import io.deuna.deuna-android-sdk.models.GetInstallments200Response
import io.deuna.deuna-android-sdk.models.OrderToken200Response
import io.deuna.deuna-android-sdk.models.OrderToken400Response
import io.deuna.deuna-android-sdk.models.OrderToken401Response
import io.deuna.deuna-android-sdk.models.OrderTokenRequest
import io.deuna.deuna-android-sdk.models.RefundOrderRequest
import io.deuna.deuna-android-sdk.models.SuccessOrderRequest
import io.deuna.deuna-android-sdk.models.VerifyPaymentOtp500Response

import com.squareup.moshi.Json

import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import io.deuna.deuna-android-sdk.infrastructure.ApiClient
import io.deuna.deuna-android-sdk.infrastructure.ApiResponse
import io.deuna.deuna-android-sdk.infrastructure.ClientException
import io.deuna.deuna-android-sdk.infrastructure.ClientError
import io.deuna.deuna-android-sdk.infrastructure.ServerException
import io.deuna.deuna-android-sdk.infrastructure.ServerError
import io.deuna.deuna-android-sdk.infrastructure.MultiValueMap
import io.deuna.deuna-android-sdk.infrastructure.PartConfig
import io.deuna.deuna-android-sdk.infrastructure.RequestConfig
import io.deuna.deuna-android-sdk.infrastructure.RequestMethod
import io.deuna.deuna-android-sdk.infrastructure.ResponseType
import io.deuna.deuna-android-sdk.infrastructure.Success
import io.deuna.deuna-android-sdk.infrastructure.toMultiValue

class OrderApi(basePath: kotlin.String = defaultBasePath, client: OkHttpClient = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://staging-apigw.getduna.com:443")
        }
    }

    /**
     * Cancelar la orden
     * Cancela una orden identificada por el token de la orden. 
     * @param orderToken 
     * @param xApiKey  (optional)
     * @param cancelOrderRequest  (optional)
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun cancelOrder(orderToken: kotlin.String, xApiKey: kotlin.String? = null, cancelOrderRequest: CancelOrderRequest? = null) : Unit = withContext(Dispatchers.IO) {
        val localVarResponse = cancelOrderWithHttpInfo(orderToken = orderToken, xApiKey = xApiKey, cancelOrderRequest = cancelOrderRequest)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Cancelar la orden
     * Cancela una orden identificada por el token de la orden. 
     * @param orderToken 
     * @param xApiKey  (optional)
     * @param cancelOrderRequest  (optional)
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun cancelOrderWithHttpInfo(orderToken: kotlin.String?, xApiKey: kotlin.String?, cancelOrderRequest: CancelOrderRequest?) : ApiResponse<Unit?> = withContext(Dispatchers.IO) {
        val localVariableConfig = cancelOrderRequestConfig(orderToken = orderToken, xApiKey = xApiKey, cancelOrderRequest = cancelOrderRequest)

        return@withContext request<CancelOrderRequest, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation cancelOrder
     *
     * @param orderToken 
     * @param xApiKey  (optional)
     * @param cancelOrderRequest  (optional)
     * @return RequestConfig
     */
    fun cancelOrderRequestConfig(orderToken: kotlin.String?, xApiKey: kotlin.String?, cancelOrderRequest: CancelOrderRequest?) : RequestConfig<CancelOrderRequest> {
        val localVariableBody = cancelOrderRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        xApiKey?.apply { localVariableHeaders["X-Api-Key"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/merchants/orders/{order_token}/cancel".replace("{"+"order_token"+"}", encodeURIComponent(orderToken.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Obtener Installments para Orden
     * Obtener Installments para Orden
     * @param orderToken 
     * @param xApiKey  (optional)
     * @param authorization  (optional)
     * @return GetInstallments200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun getInstallments(orderToken: kotlin.String, xApiKey: kotlin.String? = null, authorization: kotlin.String? = null) : GetInstallments200Response = withContext(Dispatchers.IO) {
        val localVarResponse = getInstallmentsWithHttpInfo(orderToken = orderToken, xApiKey = xApiKey, authorization = authorization)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetInstallments200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Obtener Installments para Orden
     * Obtener Installments para Orden
     * @param orderToken 
     * @param xApiKey  (optional)
     * @param authorization  (optional)
     * @return ApiResponse<GetInstallments200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun getInstallmentsWithHttpInfo(orderToken: kotlin.String?, xApiKey: kotlin.String?, authorization: kotlin.String?) : ApiResponse<GetInstallments200Response?> = withContext(Dispatchers.IO) {
        val localVariableConfig = getInstallmentsRequestConfig(orderToken = orderToken, xApiKey = xApiKey, authorization = authorization)

        return@withContext request<Unit, GetInstallments200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getInstallments
     *
     * @param orderToken 
     * @param xApiKey  (optional)
     * @param authorization  (optional)
     * @return RequestConfig
     */
    fun getInstallmentsRequestConfig(orderToken: kotlin.String?, xApiKey: kotlin.String?, authorization: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        xApiKey?.apply { localVariableHeaders["X-Api-Key"] = this.toString() }
        authorization?.apply { localVariableHeaders["Authorization"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json, multipart/form-data"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/merchants/transactions/orders/{order_token}/installments".replace("{"+"order_token"+"}", encodeURIComponent(orderToken.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Obtener orden por token
     * 
     * @param orderToken 
     * @param xApiKey  (optional)
     * @return OrderToken200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun getOrder(orderToken: kotlin.String, xApiKey: kotlin.String? = null) : OrderToken200Response = withContext(Dispatchers.IO) {
        val localVarResponse = getOrderWithHttpInfo(orderToken = orderToken, xApiKey = xApiKey)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as OrderToken200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Obtener orden por token
     * 
     * @param orderToken 
     * @param xApiKey  (optional)
     * @return ApiResponse<OrderToken200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun getOrderWithHttpInfo(orderToken: kotlin.String?, xApiKey: kotlin.String?) : ApiResponse<OrderToken200Response?> = withContext(Dispatchers.IO) {
        val localVariableConfig = getOrderRequestConfig(orderToken = orderToken, xApiKey = xApiKey)

        return@withContext request<Unit, OrderToken200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getOrder
     *
     * @param orderToken 
     * @param xApiKey  (optional)
     * @return RequestConfig
     */
    fun getOrderRequestConfig(orderToken: kotlin.String?, xApiKey: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        xApiKey?.apply { localVariableHeaders["X-Api-Key"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json, multipart/form-data"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/merchants/orders/{order_token}".replace("{"+"order_token"+"}", encodeURIComponent(orderToken.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Crear token de orden
     * Generar una orden tokenizada en DEUNA, este deberá ser usado para el resto de peticiones y para poder inicializar el checkout
     * @param xApiKey  (optional)
     * @param orderTokenRequest  (optional)
     * @return OrderToken200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun orderToken(xApiKey: kotlin.String? = null, orderTokenRequest: OrderTokenRequest? = null) : OrderToken200Response = withContext(Dispatchers.IO) {
        val localVarResponse = orderTokenWithHttpInfo(xApiKey = xApiKey, orderTokenRequest = orderTokenRequest)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as OrderToken200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Crear token de orden
     * Generar una orden tokenizada en DEUNA, este deberá ser usado para el resto de peticiones y para poder inicializar el checkout
     * @param xApiKey  (optional)
     * @param orderTokenRequest  (optional)
     * @return ApiResponse<OrderToken200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun orderTokenWithHttpInfo(xApiKey: kotlin.String?, orderTokenRequest: OrderTokenRequest?) : ApiResponse<OrderToken200Response?> = withContext(Dispatchers.IO) {
        val localVariableConfig = orderTokenRequestConfig(xApiKey = xApiKey, orderTokenRequest = orderTokenRequest)

        return@withContext request<OrderTokenRequest, OrderToken200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation orderToken
     *
     * @param xApiKey  (optional)
     * @param orderTokenRequest  (optional)
     * @return RequestConfig
     */
    fun orderTokenRequestConfig(xApiKey: kotlin.String?, orderTokenRequest: OrderTokenRequest?) : RequestConfig<OrderTokenRequest> {
        val localVariableBody = orderTokenRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        xApiKey?.apply { localVariableHeaders["X-Api-Key"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json, multipart/form-data"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/merchants/orders",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Reembolsar orden
     * Este request crea un reembolso de una orden identificada por el token de la orden, el reembolo puede ser: 1. &lt;b&gt;Reembolso total&lt;/b&gt;, en este caso no es necesario enviar el atributo &#x60;amount&#x60;. 2. &lt;b&gt;Reembolso parcial&lt;/b&gt;, debes enviar el atributo  &#x60;amount&#x60; para especificar que es un reembolso parcial, indicando la cantidad a reembolsar.
     * @param orderToken 
     * @param xApiKey  (optional)
     * @param refundOrderRequest Reembolso de la orden (optional)
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun refundOrder(orderToken: kotlin.String, xApiKey: kotlin.String? = null, refundOrderRequest: RefundOrderRequest? = null) : Unit = withContext(Dispatchers.IO) {
        val localVarResponse = refundOrderWithHttpInfo(orderToken = orderToken, xApiKey = xApiKey, refundOrderRequest = refundOrderRequest)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Reembolsar orden
     * Este request crea un reembolso de una orden identificada por el token de la orden, el reembolo puede ser: 1. &lt;b&gt;Reembolso total&lt;/b&gt;, en este caso no es necesario enviar el atributo &#x60;amount&#x60;. 2. &lt;b&gt;Reembolso parcial&lt;/b&gt;, debes enviar el atributo  &#x60;amount&#x60; para especificar que es un reembolso parcial, indicando la cantidad a reembolsar.
     * @param orderToken 
     * @param xApiKey  (optional)
     * @param refundOrderRequest Reembolso de la orden (optional)
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun refundOrderWithHttpInfo(orderToken: kotlin.String?, xApiKey: kotlin.String?, refundOrderRequest: RefundOrderRequest?) : ApiResponse<Unit?> = withContext(Dispatchers.IO) {
        val localVariableConfig = refundOrderRequestConfig(orderToken = orderToken, xApiKey = xApiKey, refundOrderRequest = refundOrderRequest)

        return@withContext request<RefundOrderRequest, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation refundOrder
     *
     * @param orderToken 
     * @param xApiKey  (optional)
     * @param refundOrderRequest Reembolso de la orden (optional)
     * @return RequestConfig
     */
    fun refundOrderRequestConfig(orderToken: kotlin.String?, xApiKey: kotlin.String?, refundOrderRequest: RefundOrderRequest?) : RequestConfig<RefundOrderRequest> {
        val localVariableBody = refundOrderRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        xApiKey?.apply { localVariableHeaders["X-Api-Key"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/merchants/orders/{order_token}/refund".replace("{"+"order_token"+"}", encodeURIComponent(orderToken.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Aprobar orden
     * Si se quiere aprobar una orden para notificar una orden de pago asíncrona como una transferencia podemos usar este método
     * @param orderToken 
     * @param xApiKey  (optional)
     * @param successOrderRequest Aprobar orden (optional)
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun successOrder(orderToken: kotlin.String, xApiKey: kotlin.String? = null, successOrderRequest: SuccessOrderRequest? = null) : Unit = withContext(Dispatchers.IO) {
        val localVarResponse = successOrderWithHttpInfo(orderToken = orderToken, xApiKey = xApiKey, successOrderRequest = successOrderRequest)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Aprobar orden
     * Si se quiere aprobar una orden para notificar una orden de pago asíncrona como una transferencia podemos usar este método
     * @param orderToken 
     * @param xApiKey  (optional)
     * @param successOrderRequest Aprobar orden (optional)
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun successOrderWithHttpInfo(orderToken: kotlin.String?, xApiKey: kotlin.String?, successOrderRequest: SuccessOrderRequest?) : ApiResponse<Unit?> = withContext(Dispatchers.IO) {
        val localVariableConfig = successOrderRequestConfig(orderToken = orderToken, xApiKey = xApiKey, successOrderRequest = successOrderRequest)

        return@withContext request<SuccessOrderRequest, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation successOrder
     *
     * @param orderToken 
     * @param xApiKey  (optional)
     * @param successOrderRequest Aprobar orden (optional)
     * @return RequestConfig
     */
    fun successOrderRequestConfig(orderToken: kotlin.String?, xApiKey: kotlin.String?, successOrderRequest: SuccessOrderRequest?) : RequestConfig<SuccessOrderRequest> {
        val localVariableBody = successOrderRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        xApiKey?.apply { localVariableHeaders["X-Api-Key"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/merchants/orders/{order_token}/success".replace("{"+"order_token"+"}", encodeURIComponent(orderToken.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Anular pago
     * Se utiliza este método cuando se quiere anular el pago de una orden 
     * @param orderToken 
     * @param xApiKey  (optional)
     * @param successOrderRequest Aprobar orden (optional)
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun voidPaymentOrder(orderToken: kotlin.String, xApiKey: kotlin.String? = null, successOrderRequest: SuccessOrderRequest? = null) : Unit = withContext(Dispatchers.IO) {
        val localVarResponse = voidPaymentOrderWithHttpInfo(orderToken = orderToken, xApiKey = xApiKey, successOrderRequest = successOrderRequest)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Anular pago
     * Se utiliza este método cuando se quiere anular el pago de una orden 
     * @param orderToken 
     * @param xApiKey  (optional)
     * @param successOrderRequest Aprobar orden (optional)
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun voidPaymentOrderWithHttpInfo(orderToken: kotlin.String?, xApiKey: kotlin.String?, successOrderRequest: SuccessOrderRequest?) : ApiResponse<Unit?> = withContext(Dispatchers.IO) {
        val localVariableConfig = voidPaymentOrderRequestConfig(orderToken = orderToken, xApiKey = xApiKey, successOrderRequest = successOrderRequest)

        return@withContext request<SuccessOrderRequest, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation voidPaymentOrder
     *
     * @param orderToken 
     * @param xApiKey  (optional)
     * @param successOrderRequest Aprobar orden (optional)
     * @return RequestConfig
     */
    fun voidPaymentOrderRequestConfig(orderToken: kotlin.String?, xApiKey: kotlin.String?, successOrderRequest: SuccessOrderRequest?) : RequestConfig<SuccessOrderRequest> {
        val localVariableBody = successOrderRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        xApiKey?.apply { localVariableHeaders["X-Api-Key"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/merchants/orders/{order_token}/void".replace("{"+"order_token"+"}", encodeURIComponent(orderToken.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
