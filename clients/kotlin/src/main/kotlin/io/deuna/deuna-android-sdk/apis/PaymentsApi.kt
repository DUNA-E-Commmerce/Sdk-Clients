/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package io.deuna.deuna-android-sdk.apis

import java.io.IOException
import okhttp3.OkHttpClient
import okhttp3.HttpUrl

import io.deuna.deuna-android-sdk.models.CaptureRequest
import io.deuna.deuna-android-sdk.models.GetMerchantsPaymentsMethods200Response
import io.deuna.deuna-android-sdk.models.GetMerchantsPaymentsMethods401Response
import io.deuna.deuna-android-sdk.models.GetMerchantsPaymentsMethods500Response
import io.deuna.deuna-android-sdk.models.GetPaymentMethods200Response
import io.deuna.deuna-android-sdk.models.GetPaymentMethods500Response
import io.deuna.deuna-android-sdk.models.GetUserCards401Response
import io.deuna.deuna-android-sdk.models.OrderToken200Response
import io.deuna.deuna-android-sdk.models.OrderToken400ResponseError
import io.deuna.deuna-android-sdk.models.OrderToken401Response
import io.deuna.deuna-android-sdk.models.Purchase200Response
import io.deuna.deuna-android-sdk.models.PurchaseRequest
import io.deuna.deuna-android-sdk.models.VerifyPaymentOtp422Response
import io.deuna.deuna-android-sdk.models.VerifyPaymentOtp500Response
import io.deuna.deuna-android-sdk.models.VerifyPaymentOtpRequest

import com.squareup.moshi.Json

import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import io.deuna.deuna-android-sdk.infrastructure.ApiClient
import io.deuna.deuna-android-sdk.infrastructure.ApiResponse
import io.deuna.deuna-android-sdk.infrastructure.ClientException
import io.deuna.deuna-android-sdk.infrastructure.ClientError
import io.deuna.deuna-android-sdk.infrastructure.ServerException
import io.deuna.deuna-android-sdk.infrastructure.ServerError
import io.deuna.deuna-android-sdk.infrastructure.MultiValueMap
import io.deuna.deuna-android-sdk.infrastructure.PartConfig
import io.deuna.deuna-android-sdk.infrastructure.RequestConfig
import io.deuna.deuna-android-sdk.infrastructure.RequestMethod
import io.deuna.deuna-android-sdk.infrastructure.ResponseType
import io.deuna.deuna-android-sdk.infrastructure.Success
import io.deuna.deuna-android-sdk.infrastructure.toMultiValue

class PaymentsApi(basePath: kotlin.String = defaultBasePath, client: OkHttpClient = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://staging-apigw.getduna.com:443")
        }
    }

    /**
     * Capturar un pago autorizado
     * La opción de **capturar un pago autorizado** te permite completar una transacción con estado **authorized**. Una transaccion esta en estado  **authorized** cuando se reservaron los fondos necesarios para dicha transacción.
     * @param orderToken 
     * @param xApiKey  (optional)
     * @param captureRequest  (optional)
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun capture(orderToken: kotlin.String, xApiKey: kotlin.String? = null, captureRequest: CaptureRequest? = null) : Unit = withContext(Dispatchers.IO) {
        val localVarResponse = captureWithHttpInfo(orderToken = orderToken, xApiKey = xApiKey, captureRequest = captureRequest)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Capturar un pago autorizado
     * La opción de **capturar un pago autorizado** te permite completar una transacción con estado **authorized**. Una transaccion esta en estado  **authorized** cuando se reservaron los fondos necesarios para dicha transacción.
     * @param orderToken 
     * @param xApiKey  (optional)
     * @param captureRequest  (optional)
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun captureWithHttpInfo(orderToken: kotlin.String?, xApiKey: kotlin.String?, captureRequest: CaptureRequest?) : ApiResponse<Unit?> = withContext(Dispatchers.IO) {
        val localVariableConfig = captureRequestConfig(orderToken = orderToken, xApiKey = xApiKey, captureRequest = captureRequest)

        return@withContext request<CaptureRequest, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation capture
     *
     * @param orderToken 
     * @param xApiKey  (optional)
     * @param captureRequest  (optional)
     * @return RequestConfig
     */
    fun captureRequestConfig(orderToken: kotlin.String?, xApiKey: kotlin.String?, captureRequest: CaptureRequest?) : RequestConfig<CaptureRequest> {
        val localVariableBody = captureRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        xApiKey?.apply { localVariableHeaders["X-Api-Key"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/merchants/orders/{order_token}/capture".replace("{"+"order_token"+"}", encodeURIComponent(orderToken.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Métodos de pago
     * Obtiene los métodos disponibles que tiene el comercio para esa orden en específico
     * @param orderToken 
     * @param xApiKey  (optional)
     * @param authorization  (optional)
     * @return GetMerchantsPaymentsMethods200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun getMerchantsPaymentsMethods(orderToken: kotlin.String, xApiKey: kotlin.String? = null, authorization: kotlin.String? = null) : GetMerchantsPaymentsMethods200Response = withContext(Dispatchers.IO) {
        val localVarResponse = getMerchantsPaymentsMethodsWithHttpInfo(orderToken = orderToken, xApiKey = xApiKey, authorization = authorization)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetMerchantsPaymentsMethods200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Métodos de pago
     * Obtiene los métodos disponibles que tiene el comercio para esa orden en específico
     * @param orderToken 
     * @param xApiKey  (optional)
     * @param authorization  (optional)
     * @return ApiResponse<GetMerchantsPaymentsMethods200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun getMerchantsPaymentsMethodsWithHttpInfo(orderToken: kotlin.String?, xApiKey: kotlin.String?, authorization: kotlin.String?) : ApiResponse<GetMerchantsPaymentsMethods200Response?> = withContext(Dispatchers.IO) {
        val localVariableConfig = getMerchantsPaymentsMethodsRequestConfig(orderToken = orderToken, xApiKey = xApiKey, authorization = authorization)

        return@withContext request<Unit, GetMerchantsPaymentsMethods200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getMerchantsPaymentsMethods
     *
     * @param orderToken 
     * @param xApiKey  (optional)
     * @param authorization  (optional)
     * @return RequestConfig
     */
    fun getMerchantsPaymentsMethodsRequestConfig(orderToken: kotlin.String?, xApiKey: kotlin.String?, authorization: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        xApiKey?.apply { localVariableHeaders["X-Api-Key"] = this.toString() }
        authorization?.apply { localVariableHeaders["Authorization"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/merchants/orders/{order_token}/payments-methods".replace("{"+"order_token"+"}", encodeURIComponent(orderToken.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Payment methods campos específicos
     * Obtén los métodos de pago asociados al comercio y su respectiva información adicional requerida.
     * @param authorization  (optional)
     * @return GetPaymentMethods200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun getPaymentMethods(authorization: kotlin.String? = null) : GetPaymentMethods200Response = withContext(Dispatchers.IO) {
        val localVarResponse = getPaymentMethodsWithHttpInfo(authorization = authorization)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetPaymentMethods200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Payment methods campos específicos
     * Obtén los métodos de pago asociados al comercio y su respectiva información adicional requerida.
     * @param authorization  (optional)
     * @return ApiResponse<GetPaymentMethods200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun getPaymentMethodsWithHttpInfo(authorization: kotlin.String?) : ApiResponse<GetPaymentMethods200Response?> = withContext(Dispatchers.IO) {
        val localVariableConfig = getPaymentMethodsRequestConfig(authorization = authorization)

        return@withContext request<Unit, GetPaymentMethods200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getPaymentMethods
     *
     * @param authorization  (optional)
     * @return RequestConfig
     */
    fun getPaymentMethodsRequestConfig(authorization: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        authorization?.apply { localVariableHeaders["Authorization"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/transactions/payments-methods",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Realizar pago de orden
     * Realiza el pago de la orden. Para los procesadores previamente configurados, al momento de hacer el pago, en la respuesta el atributo &#39;status&#39; cambiará a &#39;authorized&#39;  indicando que dicha transacción esta pendiente para realizar una captura o anulación, según sea el caso.
     * @param xApiKey  (optional)
     * @param authorization  (optional)
     * @param xDeviceId  (optional)
     * @param xSessionId  (optional)
     * @param purchaseRequest  (optional)
     * @return Purchase200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun purchase(xApiKey: kotlin.String? = null, authorization: kotlin.String? = null, xDeviceId: kotlin.String? = null, xSessionId: kotlin.String? = null, purchaseRequest: PurchaseRequest? = null) : Purchase200Response = withContext(Dispatchers.IO) {
        val localVarResponse = purchaseWithHttpInfo(xApiKey = xApiKey, authorization = authorization, xDeviceId = xDeviceId, xSessionId = xSessionId, purchaseRequest = purchaseRequest)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Purchase200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Realizar pago de orden
     * Realiza el pago de la orden. Para los procesadores previamente configurados, al momento de hacer el pago, en la respuesta el atributo &#39;status&#39; cambiará a &#39;authorized&#39;  indicando que dicha transacción esta pendiente para realizar una captura o anulación, según sea el caso.
     * @param xApiKey  (optional)
     * @param authorization  (optional)
     * @param xDeviceId  (optional)
     * @param xSessionId  (optional)
     * @param purchaseRequest  (optional)
     * @return ApiResponse<Purchase200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun purchaseWithHttpInfo(xApiKey: kotlin.String?, authorization: kotlin.String?, xDeviceId: kotlin.String?, xSessionId: kotlin.String?, purchaseRequest: PurchaseRequest?) : ApiResponse<Purchase200Response?> = withContext(Dispatchers.IO) {
        val localVariableConfig = purchaseRequestConfig(xApiKey = xApiKey, authorization = authorization, xDeviceId = xDeviceId, xSessionId = xSessionId, purchaseRequest = purchaseRequest)

        return@withContext request<PurchaseRequest, Purchase200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation purchase
     *
     * @param xApiKey  (optional)
     * @param authorization  (optional)
     * @param xDeviceId  (optional)
     * @param xSessionId  (optional)
     * @param purchaseRequest  (optional)
     * @return RequestConfig
     */
    fun purchaseRequestConfig(xApiKey: kotlin.String?, authorization: kotlin.String?, xDeviceId: kotlin.String?, xSessionId: kotlin.String?, purchaseRequest: PurchaseRequest?) : RequestConfig<PurchaseRequest> {
        val localVariableBody = purchaseRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        xApiKey?.apply { localVariableHeaders["X-Api-Key"] = this.toString() }
        authorization?.apply { localVariableHeaders["Authorization"] = this.toString() }
        xDeviceId?.apply { localVariableHeaders["X-Device-Id"] = this.toString() }
        xSessionId?.apply { localVariableHeaders["X-Session-Id"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json, multipart/form-data"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/merchants/transactions/purchase",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Verificar pago con OTP
     * Verificar el pago con el código OTP 
     * @param orderToken 
     * @param xApiKey  (optional)
     * @param authorization  (optional)
     * @param verifyPaymentOtpRequest  (optional)
     * @return OrderToken200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun verifyPaymentOtp(orderToken: kotlin.String, xApiKey: kotlin.String? = null, authorization: kotlin.String? = null, verifyPaymentOtpRequest: VerifyPaymentOtpRequest? = null) : OrderToken200Response = withContext(Dispatchers.IO) {
        val localVarResponse = verifyPaymentOtpWithHttpInfo(orderToken = orderToken, xApiKey = xApiKey, authorization = authorization, verifyPaymentOtpRequest = verifyPaymentOtpRequest)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as OrderToken200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Verificar pago con OTP
     * Verificar el pago con el código OTP 
     * @param orderToken 
     * @param xApiKey  (optional)
     * @param authorization  (optional)
     * @param verifyPaymentOtpRequest  (optional)
     * @return ApiResponse<OrderToken200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun verifyPaymentOtpWithHttpInfo(orderToken: kotlin.String?, xApiKey: kotlin.String?, authorization: kotlin.String?, verifyPaymentOtpRequest: VerifyPaymentOtpRequest?) : ApiResponse<OrderToken200Response?> = withContext(Dispatchers.IO) {
        val localVariableConfig = verifyPaymentOtpRequestConfig(orderToken = orderToken, xApiKey = xApiKey, authorization = authorization, verifyPaymentOtpRequest = verifyPaymentOtpRequest)

        return@withContext request<VerifyPaymentOtpRequest, OrderToken200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation verifyPaymentOtp
     *
     * @param orderToken 
     * @param xApiKey  (optional)
     * @param authorization  (optional)
     * @param verifyPaymentOtpRequest  (optional)
     * @return RequestConfig
     */
    fun verifyPaymentOtpRequestConfig(orderToken: kotlin.String?, xApiKey: kotlin.String?, authorization: kotlin.String?, verifyPaymentOtpRequest: VerifyPaymentOtpRequest?) : RequestConfig<VerifyPaymentOtpRequest> {
        val localVariableBody = verifyPaymentOtpRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        xApiKey?.apply { localVariableHeaders["X-Api-Key"] = this.toString() }
        authorization?.apply { localVariableHeaders["Authorization"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json, multipart/form-data"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/merchants/orders/{order_token}/transactions/verify".replace("{"+"order_token"+"}", encodeURIComponent(orderToken.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
